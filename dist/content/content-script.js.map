{
  "version": 3,
  "sources": ["../../src/utils/hash.ts", "../../src/content/subtitle-fetcher.ts", "../../src/utils/webvtt-generator.ts", "../../src/content/track-injector.ts", "../../src/content/next-lecture-detector.ts", "../../src/storage/settings-manager.ts", "../../src/content/loading-indicator.ts", "../../src/content/content-script.ts"],
  "sourcesContent": ["/**\n * Hash Utilities\n *\n * Shared hashing helpers for subtitle versioning and cache validation.\n */\n\n/**\n * Calculate SHA-256 hash of content (hex string).\n * Falls back to a simple non-cryptographic hash when crypto.subtle is unavailable.\n */\nexport async function calculateHash(content: string): Promise<string> {\n  try {\n    if (typeof crypto === 'undefined' || !crypto.subtle?.digest) {\n      throw new Error('crypto.subtle not available');\n    }\n\n    const encoder = new TextEncoder();\n    const data = encoder.encode(content);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n  } catch {\n    return simpleHash(content);\n  }\n}\n\n/**\n * Simple hash fallback (32-bit, hex string).\n * Not cryptographically secure; only used when SHA-256 is unavailable.\n */\nexport function simpleHash(str: string): string {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return Math.abs(hash).toString(16).padStart(8, '0');\n}\n\n", "/**\n * Subtitle Fetcher Module\n *\n * Responsible for detecting and fetching subtitle tracks from Udemy video player.\n *\n * Task ID: T-20251223-act-005-build-subtitle-fetch\n *\n * Acceptance Criteria:\n * - [x] Content Script \u5728 Udemy \u8BFE\u7A0B\u64AD\u653E\u9875\u52A0\u8F7D\u540E 3 \u79D2\u5185\u8BC6\u522B\u89C6\u9891\u5143\u7D20\n * - [x] \u6210\u529F\u63D0\u53D6\u539F\u59CB\u5B57\u5E55 URL\uFF08\u4F18\u5148\u82F1\u6587 WebVTT\uFF09\n * - [x] \u63A7\u5236\u53F0/\u65E5\u5FD7\u53EF\u89C1\u5B57\u5E55\u6293\u53D6\u72B6\u6001\n */\n\nimport type {\n  SubtitleTrack,\n  SubtitleFetchResult,\n  VTTContent,\n  VideoDetectionResult,\n  CourseInfo,\n  AsyncResult,\n} from '../types';\nimport { calculateHash } from '../utils/hash';\n\n// ============================================\n// Constants\n// ============================================\n\n/** Logger prefix for all subtitle fetcher logs */\nconst LOG_PREFIX = '[SubtitleFetcher]';\n\n/** Maximum time to wait for video detection (ms) */\nconst VIDEO_DETECTION_TIMEOUT = 3000;\n\n/** Polling interval for video detection (ms) */\nconst VIDEO_DETECTION_POLL_INTERVAL = 100;\n\n/** Preferred language priority for subtitle selection */\nconst LANGUAGE_PRIORITY = ['en', 'en-US', 'en-GB', 'en-AU'];\n\n// ============================================\n// Logger Utility\n// ============================================\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nlet currentLogLevel: LogLevel = 'info';\n\nfunction log(level: LogLevel, ...args: unknown[]): void {\n  if (LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel]) {\n    const method = level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log';\n    console[method](LOG_PREFIX, `[${level.toUpperCase()}]`, ...args);\n  }\n}\n\n/**\n * Set the logging level\n */\nexport function setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n// ============================================\n// URL and Course Info Extraction\n// ============================================\n\n/**\n * Extract course information from current Udemy URL\n */\nexport function extractCourseInfo(): CourseInfo | null {\n  const url = window.location.href;\n\n  // Pattern: /course/{slug}/learn/lecture/{lecture_id}\n  const match = url.match(/\\/course\\/([^\\/]+)\\/learn\\/lecture\\/(\\d+)/);\n  if (!match) {\n    log('debug', 'URL does not match Udemy course page pattern:', url);\n    return null;\n  }\n\n  const courseSlug = match[1];\n  const lectureId = match[2];\n\n  // Try to get course ID from performance entries or page data\n  const courseId = getCourseIdFromPage();\n\n  const info: CourseInfo = {\n    courseId: courseId || '',\n    courseSlug,\n    lectureId,\n    courseTitle: getCourseTitle(),\n    sectionTitle: getSectionTitle(),\n    lectureTitle: getLectureTitle(),\n  };\n\n  log('info', 'Extracted course info:', info);\n  return info;\n}\n\n/**\n * Try to get course ID from page data or network requests\n */\nfunction getCourseIdFromPage(): string {\n  // Method 1: Check UD global object (Udemy's internal data)\n  try {\n    // @ts-ignore - UD is Udemy's global object\n    if (typeof UD !== 'undefined' && UD?.config?.brand?.course?.id) {\n      // @ts-ignore\n      return String(UD.config.brand.course.id);\n    }\n  } catch (e) {\n    // UD not available\n  }\n\n  // Method 2: Check performance entries for API calls containing course ID\n  try {\n    const apiCalls = performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n    for (const call of apiCalls) {\n      const match = call.name.match(/api-2\\.0\\/courses\\/(\\d+)/);\n      if (match) {\n        return match[1];\n      }\n    }\n  } catch (e) {\n    // Performance API not available\n  }\n\n  // Method 3: Check for data attribute on page elements\n  const courseElement = document.querySelector('[data-course-id]');\n  if (courseElement) {\n    return courseElement.getAttribute('data-course-id') || '';\n  }\n\n  return '';\n}\n\n/**\n * Get course title from page\n */\nfunction getCourseTitle(): string | undefined {\n  // Try multiple selectors\n  const selectors = [\n    '[data-purpose=\"course-header-title\"]',\n    '.udlite-heading-xl',\n    'h1[class*=\"course-title\"]',\n    'title',\n  ];\n\n  for (const selector of selectors) {\n    const element = document.querySelector(selector);\n    if (element?.textContent) {\n      const text = element.textContent.trim();\n      // Clean up title (remove \" | Udemy\" suffix if from title tag)\n      return text.replace(/\\s*\\|\\s*Udemy\\s*$/i, '');\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Get current section title from sidebar\n */\nfunction getSectionTitle(): string | undefined {\n  const sectionElement = document.querySelector(\n    '[data-purpose=\"section-heading\"][aria-expanded=\"true\"]'\n  );\n  return sectionElement?.textContent?.trim();\n}\n\n/**\n * Get current lecture title\n */\nfunction getLectureTitle(): string | undefined {\n  const lectureElement = document.querySelector(\n    '[data-purpose=\"curriculum-item-link\"][aria-current=\"true\"]'\n  );\n  return lectureElement?.textContent?.trim();\n}\n\n// ============================================\n// Video Detection\n// ============================================\n\n/**\n * Detect video element on Udemy page\n * Waits up to VIDEO_DETECTION_TIMEOUT for video to appear\n */\nexport async function detectVideo(): Promise<VideoDetectionResult> {\n  log('info', 'Starting video detection...');\n  const startTime = Date.now();\n\n  return new Promise((resolve) => {\n    const check = () => {\n      const video = findVideoElement();\n      const elapsed = Date.now() - startTime;\n\n      if (video) {\n        log('info', `Video element found in ${elapsed}ms`);\n        resolve({\n          found: true,\n          video,\n          courseInfo: extractCourseInfo(),\n          timestamp: Date.now(),\n        });\n        return;\n      }\n\n      if (elapsed >= VIDEO_DETECTION_TIMEOUT) {\n        log('warn', `Video detection timeout after ${elapsed}ms`);\n        resolve({\n          found: false,\n          video: null,\n          courseInfo: extractCourseInfo(),\n          timestamp: Date.now(),\n        });\n        return;\n      }\n\n      // Continue polling\n      setTimeout(check, VIDEO_DETECTION_POLL_INTERVAL);\n    };\n\n    check();\n  });\n}\n\n/**\n * Find video element on page\n */\nfunction findVideoElement(): HTMLVideoElement | null {\n  // Primary selector: Udemy video player\n  const selectors = [\n    'video[data-purpose=\"video-player\"]',\n    'video.vjs-tech',\n    '.video-js video',\n    'video',\n  ];\n\n  for (const selector of selectors) {\n    const video = document.querySelector<HTMLVideoElement>(selector);\n    if (video && isValidVideoElement(video)) {\n      log('debug', `Found video with selector: ${selector}`);\n      return video;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Check if video element is valid and ready\n */\nfunction isValidVideoElement(video: HTMLVideoElement): boolean {\n  // Check if video has a source\n  if (!video.src && !video.querySelector('source')) {\n    return false;\n  }\n\n  // Check if video is visible\n  const rect = video.getBoundingClientRect();\n  if (rect.width === 0 || rect.height === 0) {\n    return false;\n  }\n\n  return true;\n}\n\n// ============================================\n// Subtitle Track Extraction\n// ============================================\n\n/**\n * Get subtitle tracks from video element\n */\nexport async function getSubtitleTracks(\n  video: HTMLVideoElement,\n  courseInfo?: CourseInfo | null\n): Promise<SubtitleFetchResult> {\n  log('info', 'Extracting subtitle tracks...');\n\n  const result: SubtitleFetchResult = {\n    success: false,\n    tracks: [],\n    method: 'none',\n  };\n\n  // Method 1: Check existing <track> elements\n  const trackElements = getTracksFromElements(video);\n  if (trackElements.length > 0) {\n    result.tracks = trackElements;\n    result.method = 'track-element';\n    result.success = true;\n    log('info', `Found ${trackElements.length} tracks from <track> elements`);\n    return result;\n  }\n\n  // Method 2: Check TextTrack API\n  const textTracks = getTracksFromTextTrackAPI(video);\n  if (textTracks.length > 0) {\n    // Only return early if we have tracks with valid URLs\n    // TextTrack API doesn't always expose URLs, so continue to network intercept if needed\n    const tracksWithUrls = textTracks.filter((t) => t.url);\n    if (tracksWithUrls.length > 0) {\n      result.tracks = textTracks;\n      result.method = 'videojs-api';\n      result.success = true;\n      log('info', `Found ${textTracks.length} tracks from TextTrack API`);\n      return result;\n    }\n    log('debug', `TextTrack API found ${textTracks.length} tracks but none have URLs, trying network intercept`);\n  }\n\n  // Method 3: Udemy Captions API (preferred over network intercept)\n  if (courseInfo?.lectureId) {\n    const apiTracks = await getTracksFromCaptionsAPI(courseInfo);\n    if (apiTracks.length > 0) {\n      result.tracks = apiTracks;\n      result.method = 'udemy-api';\n      result.success = true;\n      log('info', `Found ${apiTracks.length} tracks from Udemy captions API`);\n      return result;\n    }\n  }\n\n  // Method 4: Intercept network requests for VTT files (fallback)\n  const networkTracks = await getTracksFromNetworkIntercept();\n  if (networkTracks.length > 0) {\n    result.tracks = networkTracks;\n    result.method = 'network-intercept';\n    result.success = true;\n    log('info', `Found ${networkTracks.length} tracks from network intercept`);\n    return result;\n  }\n\n  log('warn', 'No subtitle tracks found');\n  result.error = 'No subtitle tracks available';\n  return result;\n}\n\n/**\n * Extract tracks from <track> DOM elements\n */\nfunction getTracksFromElements(video: HTMLVideoElement): SubtitleTrack[] {\n  const tracks: SubtitleTrack[] = [];\n  const trackElements = video.querySelectorAll('track');\n\n  trackElements.forEach((track) => {\n    if (track.src && (track.kind === 'subtitles' || track.kind === 'captions')) {\n      tracks.push({\n        url: track.src,\n        language: track.srclang || 'unknown',\n        label: track.label || track.srclang || 'Unknown',\n        isDefault: track.default,\n        kind: track.kind as 'subtitles' | 'captions',\n      });\n    }\n  });\n\n  return tracks;\n}\n\n/**\n * Extract tracks from HTML5 TextTrack API\n */\nfunction getTracksFromTextTrackAPI(video: HTMLVideoElement): SubtitleTrack[] {\n  const tracks: SubtitleTrack[] = [];\n  const textTracks = video.textTracks;\n\n  if (!textTracks || textTracks.length === 0) {\n    return tracks;\n  }\n\n  for (let i = 0; i < textTracks.length; i++) {\n    const track = textTracks[i];\n    if (track.kind === 'subtitles' || track.kind === 'captions') {\n      // Note: TextTrack API doesn't provide URL directly\n      // We need to reconstruct from cues or use other methods\n      tracks.push({\n        url: '', // URL not directly available from TextTrack API\n        language: track.language || 'unknown',\n        label: track.label || track.language || 'Unknown',\n        isDefault: track.mode === 'showing',\n        kind: track.kind as 'subtitles' | 'captions',\n      });\n    }\n  }\n\n  return tracks;\n}\n\nfunction isLikelyThumbnailSpriteVttUrl(url: URL): boolean {\n  const path = url.pathname.toLowerCase();\n  if (path.includes('thumb-sprites')) return true;\n  if (path.includes('thumb_sprites')) return true;\n  if (path.includes('storyboard')) return true;\n  if (path.includes('thumbnail')) return true;\n  return false;\n}\n\nfunction normalizeLocale(locale: string): string {\n  const normalized = locale.trim().replace(/_/g, '-');\n  const [language, region, ...rest] = normalized.split('-').filter(Boolean);\n  if (!language) return normalized;\n  if (!region) return language.toLowerCase();\n  const suffix = rest.length > 0 ? `-${rest.join('-')}` : '';\n  return `${language.toLowerCase()}-${region.toUpperCase()}${suffix}`;\n}\n\nfunction toStringIfPresent(value: unknown): string | null {\n  if (typeof value === 'string' && value.trim() !== '') return value.trim();\n  if (typeof value === 'number' && Number.isFinite(value)) return String(value);\n  return null;\n}\n\nfunction inferLanguageFromUrl(url: string): string {\n  const match =\n    url.match(/[_-]([a-z]{2}(?:-[A-Z]{2})?)[_.]/) ||\n    url.match(/lang[=_]([a-z]{2}(?:-[A-Z]{2})?)/i) ||\n    url.match(/locale[=_]([a-z]{2}(?:[_-][A-Z]{2})?)/i);\n  if (!match?.[1]) return 'unknown';\n  return normalizeLocale(match[1]);\n}\n\nfunction asAbsoluteUrl(raw: string): string {\n  try {\n    return new URL(raw).toString();\n  } catch {\n    return new URL(raw, 'https://www.udemy.com').toString();\n  }\n}\n\nfunction dedupeTracks(tracks: SubtitleTrack[]): SubtitleTrack[] {\n  const seen = new Set<string>();\n  const result: SubtitleTrack[] = [];\n  for (const track of tracks) {\n    if (!track.url) continue;\n    const normalized = asAbsoluteUrl(track.url);\n    if (seen.has(normalized)) continue;\n    seen.add(normalized);\n    result.push({ ...track, url: normalized });\n  }\n  return result;\n}\n\nfunction extractTracksFromCaptionArray(items: unknown[]): SubtitleTrack[] {\n  const tracks: SubtitleTrack[] = [];\n\n  for (const item of items) {\n    if (!item || typeof item !== 'object') continue;\n    const obj = item as Record<string, unknown>;\n\n    const url =\n      toStringIfPresent(obj.url) ||\n      toStringIfPresent(obj.download_url) ||\n      toStringIfPresent(obj.downloadUrl) ||\n      toStringIfPresent(obj.vtt_url) ||\n      toStringIfPresent(obj.vttUrl) ||\n      toStringIfPresent(obj.file) ||\n      null;\n    if (!url) continue;\n\n    const parsed = tryParseUrl(url);\n    if (parsed && isLikelyThumbnailSpriteVttUrl(parsed)) continue;\n\n    // Only keep VTT-like URLs\n    if (parsed && !looksLikeVttResource(parsed)) continue;\n    if (!parsed && !url.includes('.vtt')) continue;\n\n    const languageRaw =\n      toStringIfPresent(obj.language) ||\n      toStringIfPresent(obj.locale) ||\n      toStringIfPresent(obj.srclang) ||\n      toStringIfPresent(obj.language_code) ||\n      toStringIfPresent(obj.lang) ||\n      null;\n    const language = languageRaw ? normalizeLocale(languageRaw) : inferLanguageFromUrl(url);\n\n    const label =\n      toStringIfPresent(obj.label) ||\n      toStringIfPresent(obj.display_title) ||\n      toStringIfPresent(obj.title) ||\n      (language.toLowerCase().startsWith('en') ? 'English' : language || 'Unknown');\n\n    const isDefault =\n      (typeof obj.is_default === 'boolean' && obj.is_default) ||\n      (typeof obj.default === 'boolean' && obj.default) ||\n      language.toLowerCase() === 'en';\n\n    tracks.push({ url, language, label, isDefault, kind: 'subtitles' });\n  }\n\n  return tracks;\n}\n\nfunction collectVttUrlsRecursively(data: unknown, maxNodes: number = 2000): SubtitleTrack[] {\n  const tracks: SubtitleTrack[] = [];\n  const visited = new Set<unknown>();\n  const queue: unknown[] = [data];\n  let visitedCount = 0;\n\n  while (queue.length > 0 && visitedCount < maxNodes) {\n    const node = queue.shift();\n    if (!node || typeof node !== 'object') continue;\n    if (visited.has(node)) continue;\n    visited.add(node);\n    visitedCount++;\n\n    if (Array.isArray(node)) {\n      for (const item of node) queue.push(item);\n      continue;\n    }\n\n    const obj = node as Record<string, unknown>;\n    const keys = Object.keys(obj);\n    for (const key of keys) {\n      const value = obj[key];\n      if (typeof value === 'string') {\n        const parsed = tryParseUrl(value);\n        if (!parsed) continue;\n        if (isLikelyThumbnailSpriteVttUrl(parsed)) continue;\n        if (!looksLikeVttResource(parsed)) continue;\n\n        const languageRaw =\n          toStringIfPresent(obj.language) ||\n          toStringIfPresent(obj.locale) ||\n          toStringIfPresent(obj.srclang) ||\n          toStringIfPresent(obj.language_code) ||\n          toStringIfPresent(obj.lang) ||\n          null;\n        const language = languageRaw ? normalizeLocale(languageRaw) : inferLanguageFromUrl(value);\n        const label = language.toLowerCase().startsWith('en') ? 'English' : language || 'Unknown';\n        tracks.push({ url: value, language, label, isDefault: language.toLowerCase() === 'en', kind: 'subtitles' });\n      } else if (value && typeof value === 'object') {\n        queue.push(value);\n      }\n    }\n  }\n\n  return tracks;\n}\n\nfunction extractCaptionTracks(data: unknown): SubtitleTrack[] {\n  const tracks: SubtitleTrack[] = [];\n  const root = data as any;\n\n  const arrays: unknown[][] = [];\n  if (Array.isArray(root?.asset?.captions)) arrays.push(root.asset.captions);\n  if (Array.isArray(root?.asset?.caption_tracks)) arrays.push(root.asset.caption_tracks);\n  if (Array.isArray(root?.captions)) arrays.push(root.captions);\n  if (Array.isArray(root?.results)) arrays.push(root.results);\n\n  for (const arr of arrays) tracks.push(...extractTracksFromCaptionArray(arr));\n  tracks.push(...collectVttUrlsRecursively(data));\n\n  return dedupeTracks(tracks);\n}\n\nasync function fetchJson(url: string): Promise<unknown> {\n  const response = await fetch(url, { credentials: 'include' });\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status} for ${url}`);\n  }\n  return response.json();\n}\n\nasync function getTracksFromCaptionsAPI(courseInfo: CourseInfo): Promise<SubtitleTrack[]> {\n  const lectureId = courseInfo.lectureId;\n  if (!lectureId) return [];\n\n  const attempts: string[] = [\n    `https://www.udemy.com/api-2.0/lectures/${encodeURIComponent(lectureId)}/captions/`,\n    `https://www.udemy.com/api-2.0/lectures/${encodeURIComponent(lectureId)}/?fields[lecture]=asset&fields[asset]=captions`,\n  ];\n\n  // Some endpoints require numeric course id, but courseInfo.courseId might be missing/slug.\n  if (courseInfo.courseId && /^\\d+$/.test(courseInfo.courseId)) {\n    attempts.unshift(\n      `https://www.udemy.com/api-2.0/users/me/subscribed-courses/${encodeURIComponent(courseInfo.courseId)}/lectures/${encodeURIComponent(lectureId)}/?fields[lecture]=asset&fields[asset]=captions`\n    );\n  }\n\n  let lastError: unknown = null;\n  for (const url of attempts) {\n    try {\n      const data = await fetchJson(url);\n      const tracks = extractCaptionTracks(data);\n      if (tracks.length > 0) return tracks;\n      lastError = new Error('No caption tracks found');\n    } catch (error) {\n      lastError = error;\n    }\n  }\n\n  log('debug', 'Captions API lookup failed:', lastError);\n  return [];\n}\n\n/**\n * Try to get subtitle URLs from intercepted network requests\n */\nasync function getTracksFromNetworkIntercept(): Promise<SubtitleTrack[]> {\n  const tracks: SubtitleTrack[] = [];\n\n  try {\n    // Check performance entries for VTT file requests\n    const entries = performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n\n    for (const entry of entries) {\n      const parsed = tryParseUrl(entry.name);\n      if (!parsed) continue;\n\n      if (isLikelyThumbnailSpriteVttUrl(parsed)) continue;\n      if (!looksLikeVttResource(parsed)) continue;\n\n      // Try to extract language from URL\n      const langMatch =\n        entry.name.match(/[_-]([a-z]{2}(?:-[A-Z]{2})?)[_.]/) ||\n        entry.name.match(/lang[=_]([a-z]{2}(?:-[A-Z]{2})?)/i) ||\n        entry.name.match(/locale[=_]([a-z]{2}(?:[_-][A-Z]{2})?)/i);\n      const language = langMatch ? langMatch[1].replace(/_/g, '-') : 'unknown';\n\n      tracks.push({\n        url: entry.name,\n        language,\n        label:\n          language.toLowerCase().startsWith('en')\n            ? 'English'\n            : language === 'unknown'\n              ? 'Unknown'\n              : language,\n        isDefault: language.toLowerCase() === 'en',\n        kind: 'subtitles',\n      });\n    }\n\n    // Deduplicate by URL\n    const uniqueTracks = tracks.filter(\n      (track, index, self) =>\n        index === self.findIndex((t) => t.url === track.url)\n    );\n\n    return uniqueTracks;\n  } catch (e) {\n    log('debug', 'Network intercept failed:', e);\n    return [];\n  }\n}\n\nfunction tryParseUrl(raw: string): URL | null {\n  try {\n    return new URL(raw);\n  } catch {\n    try {\n      return new URL(raw, 'https://www.udemy.com');\n    } catch {\n      return null;\n    }\n  }\n}\n\nfunction looksLikeVttResource(url: URL): boolean {\n  const pathname = url.pathname.toLowerCase();\n  if (pathname.includes('.vtt')) return true;\n\n  const keys = ['format', 'type', 'fmt', 'ext', 'extension', 'mime'];\n  for (const key of keys) {\n    const value = url.searchParams.get(key);\n    if (!value) continue;\n    const normalized = value.toLowerCase();\n    if (normalized === 'vtt' || normalized === 'text/vtt' || normalized === 'webvtt') return true;\n  }\n\n  return false;\n}\n\nfunction isLikelyThumbnailSpriteVttContent(content: string): boolean {\n  const sample = content.replace(/^\\uFEFF/, '').slice(0, 20000).toLowerCase();\n  const xywhHits = sample.match(/#xywh=/g)?.length ?? 0;\n  if (xywhHits === 0) return false;\n  if (xywhHits >= 3) return true;\n  return (\n    sample.includes('thumb-sprites') ||\n    sample.includes('thumb_sprites') ||\n    sample.includes('storyboard') ||\n    sample.includes('thumbnail')\n  );\n}\n\n/**\n * Select the best subtitle track based on language priority\n */\nexport function selectPreferredTrack(tracks: SubtitleTrack[]): SubtitleTrack | null {\n  if (tracks.length === 0) {\n    return null;\n  }\n\n  // Check for preferred languages in order\n  for (const lang of LANGUAGE_PRIORITY) {\n    const track = tracks.find(\n      (t) => t.language.toLowerCase() === lang.toLowerCase()\n    );\n    if (track) {\n      log('info', `Selected track: ${track.label} (${track.language})`);\n      return track;\n    }\n  }\n\n  // Check for any English variant\n  const englishTrack = tracks.find((t) =>\n    t.language.toLowerCase().startsWith('en')\n  );\n  if (englishTrack) {\n    log('info', `Selected English track: ${englishTrack.label}`);\n    return englishTrack;\n  }\n\n  // Check for default track\n  const defaultTrack = tracks.find((t) => t.isDefault);\n  if (defaultTrack) {\n    log('info', `Selected default track: ${defaultTrack.label}`);\n    return defaultTrack;\n  }\n\n  // Fall back to first track\n  log('info', `Selected first available track: ${tracks[0].label}`);\n  return tracks[0];\n}\n\n// ============================================\n// VTT Content Fetching\n// ============================================\n\n/**\n * Fetch VTT content from URL via background script\n * Background script can bypass CORS restrictions with proper host_permissions\n */\nexport async function fetchVTT(url: string): Promise<AsyncResult<VTTContent>> {\n  log('info', `Fetching VTT from: ${url}`);\n\n  if (!url) {\n    return {\n      success: false,\n      error: 'No URL provided',\n    };\n  }\n\n  try {\n    let content: string;\n\n    // Use background script to fetch VTT to bypass CORS in extension context.\n    // For unit tests / non-extension environments, fall back to direct fetch().\n    if (typeof chrome !== 'undefined' && !!chrome.runtime?.sendMessage) {\n      const response = await chrome.runtime.sendMessage({\n        type: 'FETCH_VTT',\n        payload: { url },\n      });\n\n      if (!response?.ok) {\n        const errorMsg = response?.error || 'Failed to fetch VTT';\n        log('error', `VTT fetch failed: ${errorMsg}`);\n        return {\n          success: false,\n          error: errorMsg,\n        };\n      }\n\n      content = response.content;\n    } else {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10000);\n\n      try {\n        const response = await fetch(url, { credentials: 'include', signal: controller.signal });\n        if (!response.ok) {\n          return {\n            success: false,\n            error: `HTTP ${response.status}: ${response.statusText}`,\n          };\n        }\n        content = await response.text();\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        const isTimeout = message.toLowerCase().includes('aborted');\n        return {\n          success: false,\n          error: isTimeout ? 'Request timeout' : message,\n        };\n      } finally {\n        clearTimeout(timeoutId);\n      }\n    }\n\n    // Validate VTT content\n    if (!isValidVTT(content)) {\n      log('error', 'Invalid VTT content received');\n      return {\n        success: false,\n        error: 'Invalid VTT format',\n      };\n    }\n\n    // Extract language from URL\n    const langMatch = url.match(/[_-]([a-z]{2}(?:-[A-Z]{2})?)[_.]/) ||\n                     url.match(/lang[=_]([a-z]{2}(?:-[A-Z]{2})?)/i);\n    const language = langMatch ? langMatch[1] : 'unknown';\n\n    // Calculate hash for cache validation\n    const hash = await calculateHash(content);\n\n    log('info', `VTT fetched successfully: ${content.length} bytes, hash: ${hash.substring(0, 8)}...`);\n\n    return {\n      success: true,\n      data: {\n        content,\n        url,\n        language,\n        hash,\n      },\n    };\n  } catch (e) {\n    const error = e instanceof Error ? e.message : 'Unknown error';\n    log('error', `VTT fetch error: ${error}`);\n\n    return {\n      success: false,\n      error,\n    };\n  }\n}\n\n/**\n * Validate VTT content format\n */\nfunction isValidVTT(content: string): boolean {\n  // VTT file must start with WEBVTT\n  // Strip BOM (U+FEFF) if present - common from some CDNs\n  const stripped = content.replace(/^\\uFEFF/, '').trim();\n  return stripped.startsWith('WEBVTT');\n}\n\n// ============================================\n// Main API\n// ============================================\n\n/**\n * Main entry point: Detect video and fetch subtitles\n *\n * This is the primary function to be called from the content script entry point.\n * It handles the complete flow:\n * 1. Detect video element\n * 2. Extract available subtitle tracks\n * 3. Select preferred track (English by default)\n * 4. Fetch VTT content\n *\n * @returns Result containing video detection status and subtitle content\n */\nexport async function fetchSubtitles(): Promise<{\n  videoDetection: VideoDetectionResult;\n  subtitleResult: SubtitleFetchResult;\n  vttContent: VTTContent | null;\n  selectedTrack: SubtitleTrack | null;\n}> {\n  log('info', '=== Starting subtitle fetch process ===');\n\n  // Step 1: Detect video\n  const videoDetection = await detectVideo();\n  if (!videoDetection.found || !videoDetection.video) {\n    log('warn', 'Video not found, aborting subtitle fetch');\n    return {\n      videoDetection,\n      subtitleResult: {\n        success: false,\n        tracks: [],\n        method: 'none',\n        error: 'Video element not found',\n      },\n      vttContent: null,\n      selectedTrack: null,\n    };\n  }\n\n  // Step 2: Get subtitle tracks\n  const subtitleResult = await getSubtitleTracks(videoDetection.video, videoDetection.courseInfo);\n  if (!subtitleResult.success || subtitleResult.tracks.length === 0) {\n    log('warn', 'No subtitle tracks found');\n    return {\n      videoDetection,\n      subtitleResult,\n      vttContent: null,\n      selectedTrack: null,\n    };\n  }\n\n  // Step 3: Select preferred track\n  const candidateTracks = subtitleResult.tracks.filter((track) => track.url);\n  const preferredTrack = selectPreferredTrack(candidateTracks);\n  if (!preferredTrack || !preferredTrack.url) {\n    log('warn', 'No suitable track selected or track has no URL');\n    return {\n      videoDetection,\n      subtitleResult,\n      vttContent: null,\n      selectedTrack: preferredTrack,\n    };\n  }\n\n  // Step 4: Fetch VTT content\n  const orderedTracks = [\n    preferredTrack,\n    ...candidateTracks.filter((track) => track.url !== preferredTrack.url),\n  ];\n\n  let selectedTrack: SubtitleTrack | null = null;\n  let vttContent: VTTContent | null = null;\n\n  for (const track of orderedTracks) {\n    const vttResult = await fetchVTT(track.url);\n    if (vttResult.success && vttResult.data) {\n      if (isLikelyThumbnailSpriteVttContent(vttResult.data.content)) {\n        log('warn', `Detected thumbnail sprite VTT, skipping track: ${track.label} (${track.language})`);\n        continue;\n      }\n      selectedTrack = track;\n      vttContent = vttResult.data;\n      break;\n    }\n    log(\n      'warn',\n      `Failed to fetch VTT for track ${track.label} (${track.language}): ${vttResult.error || 'unknown error'}`\n    );\n  }\n\n  log('info', '=== Subtitle fetch process complete ===');\n\n  return {\n    videoDetection,\n    subtitleResult,\n    vttContent,\n    selectedTrack,\n  };\n}\n\n/**\n * Export SubtitleFetcher class for object-oriented usage\n */\nexport class SubtitleFetcher {\n  private video: HTMLVideoElement | null = null;\n  private courseInfo: CourseInfo | null = null;\n  private tracks: SubtitleTrack[] = [];\n\n  /**\n   * Initialize the fetcher by detecting video and extracting info\n   */\n  async initialize(): Promise<boolean> {\n    const result = await detectVideo();\n    this.video = result.video;\n    this.courseInfo = result.courseInfo;\n    return result.found;\n  }\n\n  /**\n   * Get the detected video element\n   */\n  getVideo(): HTMLVideoElement | null {\n    return this.video;\n  }\n\n  /**\n   * Get extracted course information\n   */\n  getCourseInfo(): CourseInfo | null {\n    return this.courseInfo;\n  }\n\n  /**\n   * Get available subtitle tracks\n   */\n  async getSubtitleTracks(): Promise<SubtitleTrack[]> {\n    if (!this.video) {\n      log('warn', 'Video not initialized');\n      return [];\n    }\n\n    const result = await getSubtitleTracks(this.video, this.courseInfo);\n    this.tracks = result.tracks;\n    return this.tracks;\n  }\n\n  /**\n   * Fetch VTT content from a track\n   */\n  async fetchVTT(url: string): Promise<VTTContent | null> {\n    const result = await fetchVTT(url);\n    return result.success ? result.data! : null;\n  }\n\n  /**\n   * Select preferred track from available tracks\n   */\n  selectPreferredTrack(): SubtitleTrack | null {\n    return selectPreferredTrack(this.tracks);\n  }\n}\n\n// Export for direct use\nexport default {\n  fetchSubtitles,\n  detectVideo,\n  getSubtitleTracks,\n  fetchVTT,\n  selectPreferredTrack,\n  extractCourseInfo,\n  setLogLevel,\n  SubtitleFetcher,\n};\n", "/**\n * WebVTT Generator Module\n *\n * Generates WebVTT (Web Video Text Tracks) files from structured data.\n * Produces valid WebVTT output that can be used directly in browsers.\n *\n * Task ID: T-20251223-act-006-build-webvtt-parser\n *\n * Acceptance Criteria:\n * - [x] \u751F\u6210\u5668\u53EF\u5C06\u89E3\u6790\u7ED3\u679C\u8FD8\u539F\u4E3A\u6709\u6548 WebVTT \u5B57\u7B26\u4E32\n * - [x] \u89E3\u6790\u540E\u518D\u751F\u6210\u7684\u6587\u4EF6\u4E0E\u539F\u6587\u4EF6\u8BED\u4E49\u7B49\u4EF7\n *\n * @see https://www.w3.org/TR/webvtt1/\n */\n\nimport type {\n  VTTTimestamp,\n  VTTCue,\n  VTTFile,\n  VTTGeneratorOptions,\n} from '../types';\n\n// ============================================\n// Constants\n// ============================================\n\n/** Logger prefix */\nconst LOG_PREFIX = '[WebVTT Generator]';\n\n/** WebVTT file signature */\nconst WEBVTT_SIGNATURE = 'WEBVTT';\n\n/** Default generator options */\nconst DEFAULT_OPTIONS: VTTGeneratorOptions = {\n  includeCueIds: true,\n  includeStyles: true,\n  includeRegions: true,\n  includeNotes: true,\n  useShortTimestamp: false,\n};\n\n// ============================================\n// Logger\n// ============================================\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nlet currentLogLevel: LogLevel = 'warn';\n\nfunction log(level: LogLevel, ...args: unknown[]): void {\n  if (LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel]) {\n    const method = level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log';\n    console[method](LOG_PREFIX, `[${level.toUpperCase()}]`, ...args);\n  }\n}\n\n/**\n * Set the logging level for the generator\n */\nexport function setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n// ============================================\n// Timestamp Formatting\n// ============================================\n\n/**\n * Format a VTTTimestamp to string\n *\n * @param timestamp - Timestamp object to format\n * @param useShort - Use short format (MM:SS.mmm) when hours is 0\n * @returns Formatted timestamp string\n */\nexport function formatTimestamp(\n  timestamp: VTTTimestamp,\n  useShort: boolean = false\n): string {\n  const { hours, minutes, seconds, milliseconds } = timestamp;\n\n  const mm = minutes.toString().padStart(2, '0');\n  const ss = seconds.toString().padStart(2, '0');\n  const ms = milliseconds.toString().padStart(3, '0');\n\n  if (useShort && hours === 0) {\n    return `${mm}:${ss}.${ms}`;\n  }\n\n  const hh = hours.toString().padStart(2, '0');\n  return `${hh}:${mm}:${ss}.${ms}`;\n}\n\n/**\n * Create a VTTTimestamp from individual components\n */\nexport function createTimestamp(\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number\n): VTTTimestamp {\n  return { hours, minutes, seconds, milliseconds };\n}\n\n/**\n * Create a VTTTimestamp from total milliseconds\n */\nexport function timestampFromMs(totalMs: number): VTTTimestamp {\n  const hours = Math.floor(totalMs / 3600000);\n  totalMs %= 3600000;\n  const minutes = Math.floor(totalMs / 60000);\n  totalMs %= 60000;\n  const seconds = Math.floor(totalMs / 1000);\n  const milliseconds = totalMs % 1000;\n\n  return { hours, minutes, seconds, milliseconds };\n}\n\n// ============================================\n// Cue Generation\n// ============================================\n\n/**\n * Generate a single cue block\n *\n * @param cue - Cue object to generate\n * @param options - Generator options\n * @returns Cue block string\n */\nexport function generateCue(\n  cue: VTTCue,\n  options: VTTGeneratorOptions = DEFAULT_OPTIONS\n): string {\n  const lines: string[] = [];\n\n  // Add cue ID if present and option enabled\n  if (cue.id && options.includeCueIds !== false) {\n    lines.push(cue.id);\n  }\n\n  // Format timing line\n  const startTime = formatTimestamp(cue.startTime, options.useShortTimestamp);\n  const endTime = formatTimestamp(cue.endTime, options.useShortTimestamp);\n\n  let timingLine = `${startTime} --> ${endTime}`;\n\n  // Add cue settings if present\n  if (cue.settings) {\n    timingLine += ` ${cue.settings}`;\n  }\n\n  lines.push(timingLine);\n\n  // Add cue text\n  if (cue.text) {\n    lines.push(cue.text);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Create a new VTTCue object\n */\nexport function createCue(\n  startTime: VTTTimestamp,\n  endTime: VTTTimestamp,\n  text: string,\n  id?: string,\n  settings?: string\n): VTTCue {\n  const cue: VTTCue = {\n    startTime,\n    endTime,\n    text,\n  };\n\n  if (id) {\n    cue.id = id;\n  }\n\n  if (settings) {\n    cue.settings = settings;\n  }\n\n  return cue;\n}\n\n// ============================================\n// Main Generator\n// ============================================\n\n/**\n * Generate a complete WebVTT file string from structured data\n *\n * @param vttFile - Parsed VTT file structure\n * @param options - Generator options\n * @returns WebVTT file content string\n */\nexport function generateVTT(\n  vttFile: VTTFile,\n  options: VTTGeneratorOptions = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const lines: string[] = [];\n\n  // Generate header line\n  let headerLine = WEBVTT_SIGNATURE;\n  if (vttFile.header) {\n    headerLine += ` ${vttFile.header}`;\n  }\n  lines.push(headerLine);\n  lines.push(''); // Empty line after header\n\n  // Generate style blocks\n  if (opts.includeStyles && vttFile.styles && vttFile.styles.length > 0) {\n    for (const style of vttFile.styles) {\n      lines.push('STYLE');\n      lines.push(style);\n      lines.push('');\n    }\n  }\n\n  // Generate region blocks\n  if (opts.includeRegions && vttFile.regions && vttFile.regions.length > 0) {\n    for (const region of vttFile.regions) {\n      lines.push('REGION');\n      lines.push(region.settings);\n      lines.push('');\n    }\n  }\n\n  // Generate notes (if option enabled)\n  if (opts.includeNotes && vttFile.notes && vttFile.notes.length > 0) {\n    for (const note of vttFile.notes) {\n      lines.push(`NOTE ${note}`);\n      lines.push('');\n    }\n  }\n\n  // Generate cues\n  for (let i = 0; i < vttFile.cues.length; i++) {\n    const cue = vttFile.cues[i];\n    lines.push(generateCue(cue, opts));\n\n    // Add empty line between cues (but not after the last one)\n    if (i < vttFile.cues.length - 1) {\n      lines.push('');\n    }\n  }\n\n  log('info', `Generated WebVTT with ${vttFile.cues.length} cues`);\n\n  return lines.join('\\n');\n}\n\n/**\n * Generate a minimal WebVTT file from an array of cues\n *\n * @param cues - Array of cues\n * @param header - Optional header text\n * @returns WebVTT file content string\n */\nexport function generateFromCues(\n  cues: VTTCue[],\n  header?: string\n): string {\n  const vttFile: VTTFile = {\n    header,\n    cues,\n  };\n\n  return generateVTT(vttFile);\n}\n\n/**\n * Generate a WebVTT data URI for use in <track> elements\n *\n * @param vttFile - VTT file structure or string content\n * @returns Data URI string\n */\nexport function generateDataUri(\n  vttFile: VTTFile | string\n): string {\n  const content = typeof vttFile === 'string' ? vttFile : generateVTT(vttFile);\n\n  // Encode as base64\n  const base64 = typeof btoa === 'function'\n    ? btoa(unescape(encodeURIComponent(content)))\n    : Buffer.from(content, 'utf-8').toString('base64');\n\n  return `data:text/vtt;base64,${base64}`;\n}\n\n/**\n * Generate a Blob URL for use in <track> elements\n * Note: This function only works in browser environments\n *\n * @param vttFile - VTT file structure or string content\n * @returns Blob URL string\n */\nexport function generateBlobUrl(\n  vttFile: VTTFile | string\n): string {\n  if (typeof Blob === 'undefined' || typeof URL === 'undefined') {\n    throw new Error('Blob URLs are not supported in this environment');\n  }\n\n  const content = typeof vttFile === 'string' ? vttFile : generateVTT(vttFile);\n  const blob = new Blob([content], { type: 'text/vtt' });\n  return URL.createObjectURL(blob);\n}\n\n// ============================================\n// Helper Functions\n// ============================================\n\n/**\n * Clone a VTTFile with replaced cue texts\n *\n * This is useful for translation: keep all timing and structure,\n * but replace the text content of cues.\n *\n * @param original - Original VTT file\n * @param newTexts - Array of new text content (must match cue count)\n * @returns New VTTFile with replaced texts\n */\nexport function replaceCueTexts(\n  original: VTTFile,\n  newTexts: string[]\n): VTTFile {\n  if (newTexts.length !== original.cues.length) {\n    log('warn', `Text count (${newTexts.length}) doesn't match cue count (${original.cues.length})`);\n  }\n\n  const newCues: VTTCue[] = original.cues.map((cue, index) => ({\n    ...cue,\n    text: index < newTexts.length ? newTexts[index] : cue.text,\n  }));\n\n  return {\n    ...original,\n    cues: newCues,\n  };\n}\n\n/**\n * Merge multiple VTT files into one\n *\n * @param files - Array of VTT files to merge\n * @returns Merged VTT file\n */\nexport function mergeVTTFiles(files: VTTFile[]): VTTFile {\n  if (files.length === 0) {\n    return { cues: [] };\n  }\n\n  const merged: VTTFile = {\n    header: files[0].header,\n    cues: [],\n    styles: [],\n    regions: [],\n    notes: [],\n  };\n\n  for (const file of files) {\n    merged.cues.push(...file.cues);\n\n    if (file.styles) {\n      merged.styles!.push(...file.styles);\n    }\n    if (file.regions) {\n      merged.regions!.push(...file.regions);\n    }\n    if (file.notes) {\n      merged.notes!.push(...file.notes);\n    }\n  }\n\n  // Sort cues by start time\n  merged.cues.sort((a, b) => {\n    const aMs =\n      a.startTime.hours * 3600000 +\n      a.startTime.minutes * 60000 +\n      a.startTime.seconds * 1000 +\n      a.startTime.milliseconds;\n    const bMs =\n      b.startTime.hours * 3600000 +\n      b.startTime.minutes * 60000 +\n      b.startTime.seconds * 1000 +\n      b.startTime.milliseconds;\n    return aMs - bMs;\n  });\n\n  // Clean up empty arrays\n  if (merged.styles!.length === 0) delete merged.styles;\n  if (merged.regions!.length === 0) delete merged.regions;\n  if (merged.notes!.length === 0) delete merged.notes;\n\n  return merged;\n}\n\n/**\n * Extract all cue texts as an array\n *\n * @param vttFile - VTT file\n * @returns Array of cue text strings\n */\nexport function extractCueTexts(vttFile: VTTFile): string[] {\n  return vttFile.cues.map((cue) => cue.text);\n}\n\n/**\n * Validate that a VTTFile structure is well-formed\n *\n * @param vttFile - VTT file to validate\n * @returns Validation result with any errors\n */\nexport function validateVTTFile(vttFile: VTTFile): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (!vttFile) {\n    return { valid: false, errors: ['VTT file is null or undefined'] };\n  }\n\n  if (!Array.isArray(vttFile.cues)) {\n    return { valid: false, errors: ['VTT file has no cues array'] };\n  }\n\n  for (let i = 0; i < vttFile.cues.length; i++) {\n    const cue = vttFile.cues[i];\n    const cuePrefix = `Cue ${i + 1}${cue.id ? ` (${cue.id})` : ''}`;\n\n    if (!cue.startTime || !cue.endTime) {\n      errors.push(`${cuePrefix}: missing start or end time`);\n      continue;\n    }\n\n    // Validate timestamp components\n    const { startTime, endTime } = cue;\n\n    if (\n      startTime.hours < 0 ||\n      startTime.minutes < 0 ||\n      startTime.minutes > 59 ||\n      startTime.seconds < 0 ||\n      startTime.seconds > 59 ||\n      startTime.milliseconds < 0 ||\n      startTime.milliseconds > 999\n    ) {\n      errors.push(`${cuePrefix}: invalid start timestamp`);\n    }\n\n    if (\n      endTime.hours < 0 ||\n      endTime.minutes < 0 ||\n      endTime.minutes > 59 ||\n      endTime.seconds < 0 ||\n      endTime.seconds > 59 ||\n      endTime.milliseconds < 0 ||\n      endTime.milliseconds > 999\n    ) {\n      errors.push(`${cuePrefix}: invalid end timestamp`);\n    }\n\n    // Check that start time is before end time\n    const startMs =\n      startTime.hours * 3600000 +\n      startTime.minutes * 60000 +\n      startTime.seconds * 1000 +\n      startTime.milliseconds;\n    const endMs =\n      endTime.hours * 3600000 +\n      endTime.minutes * 60000 +\n      endTime.seconds * 1000 +\n      endTime.milliseconds;\n\n    if (startMs >= endMs) {\n      errors.push(`${cuePrefix}: start time >= end time`);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n// ============================================\n// Exports\n// ============================================\n\nexport default {\n  generateVTT,\n  generateCue,\n  generateFromCues,\n  generateDataUri,\n  generateBlobUrl,\n  formatTimestamp,\n  createTimestamp,\n  timestampFromMs,\n  createCue,\n  replaceCueTexts,\n  mergeVTTFiles,\n  extractCueTexts,\n  validateVTTFile,\n  setLogLevel,\n};\n", "/**\n * Track Injector Module\n *\n * Dynamically injects translated subtitle tracks into Udemy video player.\n * Uses Data URI approach to bypass CSP restrictions.\n *\n * Task ID: T-20251223-act-008-build-track-injector\n *\n * Acceptance Criteria:\n * - [x] \u52A8\u6001\u521B\u5EFA <track> \u5143\u7D20\u5E76\u6DFB\u52A0\u5230\u89C6\u9891 DOM\n * - [x] \u4F7F\u7528 data URI \u6216 chrome.runtime.getURL \u7ED5\u8FC7 CSP\n * - [x] Udemy \u64AD\u653E\u5668\u5B57\u5E55\u83DC\u5355\u663E\u793A\"\u4E2D\u6587\uFF08\u4F18\u5316\uFF09\"\u8F68\u9053\u9009\u9879\n * - [x] \u9009\u4E2D\u540E\u5B57\u5E55\u540C\u6B65\u89C6\u9891\u65F6\u95F4\u8F74\u6B63\u5E38\u663E\u793A\n * - [x] \u5168\u5C4F\u6A21\u5F0F\u4E0B\u5B57\u5E55\u6837\u5F0F\u4E0E\u539F\u751F\u4E00\u81F4\n * - [x] \u7A97\u53E3\u5927\u5C0F\u53D8\u5316\u65F6\u5B57\u5E55\u81EA\u52A8\u9002\u914D\n *\n * @see spike-report-track-inject.md\n */\n\nimport { generateDataUri } from '../utils/webvtt-generator';\nimport type { VTTFile } from '../types';\n\n// ============================================\n// Types\n// ============================================\n\n/**\n * Track injection options\n */\nexport interface TrackInjectionOptions {\n  /** Track label displayed in subtitle menu */\n  label?: string;\n  /** Language code (e.g., 'zh-CN') */\n  language?: string;\n  /** Track kind: 'subtitles' or 'captions' */\n  kind?: 'subtitles' | 'captions';\n  /** Whether to activate the track immediately after injection */\n  activate?: boolean;\n  /** Whether to deactivate other tracks when activating this one */\n  exclusive?: boolean;\n}\n\n/**\n * Result of track injection operation\n */\nexport interface TrackInjectionResult {\n  /** Whether injection succeeded */\n  success: boolean;\n  /** The injected track element (if successful) */\n  track?: HTMLTrackElement;\n  /** Error message if injection failed */\n  error?: string;\n  /** Method used for injection */\n  method: 'data-uri' | 'blob-url' | 'text-track-api';\n}\n\n/**\n * Information about an injected track\n */\nexport interface InjectedTrackInfo {\n  /** Track element reference */\n  element: HTMLTrackElement;\n  /** Track label */\n  label: string;\n  /** Language code */\n  language: string;\n  /** Track kind */\n  kind: 'subtitles' | 'captions';\n  /** Data URI or Blob URL */\n  src: string;\n  /** Whether track is currently active */\n  isActive: boolean;\n  /** Whether track uses exclusive activation (deactivates other tracks) */\n  exclusive: boolean;\n  /** Injection timestamp */\n  injectedAt: number;\n}\n\n/**\n * Track activation state\n */\nexport type TrackMode = 'disabled' | 'hidden' | 'showing';\n\n// ============================================\n// Constants\n// ============================================\n\n/** Logger prefix */\nconst LOG_PREFIX = '[TrackInjector]';\n\n/** Default track label */\nexport const DEFAULT_LABEL = '\u4E2D\u6587\uFF08\u4F18\u5316\uFF09';\n\n/** Default language code */\nexport const DEFAULT_LANGUAGE = 'zh-CN';\n\n/** Custom attribute to identify our injected tracks */\nexport const INJECTED_TRACK_ATTR = 'data-udemy-caption-plus';\n\n/** Event dispatched when track is injected */\nexport const TRACK_INJECTED_EVENT = 'udemycaptionplus:trackinjected';\n\n/** Event dispatched when track is activated */\nexport const TRACK_ACTIVATED_EVENT = 'udemycaptionplus:trackactivated';\n\n// ============================================\n// Logger\n// ============================================\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nlet currentLogLevel: LogLevel = 'info';\n\nfunction log(level: LogLevel, ...args: unknown[]): void {\n  if (LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel]) {\n    const method = level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log';\n    console[method](LOG_PREFIX, `[${level.toUpperCase()}]`, ...args);\n  }\n}\n\n/**\n * Set the logging level for the injector\n */\nexport function setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n// ============================================\n// State Management\n// ============================================\n\n/** Map of video elements to their injected tracks */\nconst injectedTracks = new WeakMap<HTMLVideoElement, InjectedTrackInfo[]>();\n\n/** Track cleanup handlers */\nconst cleanupHandlers = new WeakMap<HTMLVideoElement, () => void>();\n\n/**\n * Get all injected tracks for a video element\n */\nexport function getInjectedTracks(video: HTMLVideoElement): InjectedTrackInfo[] {\n  return injectedTracks.get(video) || [];\n}\n\n/**\n * Register an injected track\n */\nfunction registerTrack(video: HTMLVideoElement, trackInfo: InjectedTrackInfo): void {\n  const tracks = injectedTracks.get(video) || [];\n  tracks.push(trackInfo);\n  injectedTracks.set(video, tracks);\n}\n\n/**\n * Unregister an injected track\n */\nfunction unregisterTrack(video: HTMLVideoElement, trackElement: HTMLTrackElement): void {\n  const tracks = injectedTracks.get(video) || [];\n  const index = tracks.findIndex((t) => t.element === trackElement);\n  if (index !== -1) {\n    tracks.splice(index, 1);\n    injectedTracks.set(video, tracks);\n  }\n}\n\n// ============================================\n// Core Injection Functions\n// ============================================\n\n/**\n * Inject a translated subtitle track into a video element\n *\n * @param video - Target video element\n * @param vttContent - VTT content (string or parsed VTTFile)\n * @param options - Injection options\n * @returns Injection result\n */\nexport function injectTrack(\n  video: HTMLVideoElement,\n  vttContent: string | VTTFile,\n  options: TrackInjectionOptions = {}\n): TrackInjectionResult {\n  const {\n    label = DEFAULT_LABEL,\n    language = DEFAULT_LANGUAGE,\n    kind = 'subtitles',\n    activate = true,\n    exclusive = true,\n  } = options;\n\n  log('info', `Injecting track: \"${label}\" (${language})`);\n\n  // Validate video element\n  if (!video || !(video instanceof HTMLVideoElement)) {\n    log('error', 'Invalid video element');\n    return {\n      success: false,\n      error: 'Invalid video element',\n      method: 'data-uri',\n    };\n  }\n\n  // Check if we already injected a track with the same label\n  const existingTracks = getInjectedTracks(video);\n  const existingTrack = existingTracks.find((t) => t.label === label);\n  if (existingTrack) {\n    log('info', `Track \"${label}\" already exists, updating...`);\n    // Remove existing track and inject new one\n    removeTrack(video, existingTrack.element);\n  }\n\n  try {\n    // Generate Data URI from VTT content\n    const dataUri = generateDataUri(vttContent);\n\n    // Create track element\n    const track = document.createElement('track');\n    track.kind = kind;\n    track.label = label;\n    track.srclang = language;\n    track.src = dataUri;\n    track.setAttribute(INJECTED_TRACK_ATTR, 'true');\n\n    // Add track to video\n    video.appendChild(track);\n\n    // Wait for track to load before activating\n    track.addEventListener('load', () => {\n      log('debug', `Track \"${label}\" loaded successfully`);\n    }, { once: true });\n\n    track.addEventListener('error', (e) => {\n      log('error', `Track \"${label}\" failed to load:`, e);\n    }, { once: true });\n\n    // Register track\n    const trackInfo: InjectedTrackInfo = {\n      element: track,\n      label,\n      language,\n      kind,\n      src: dataUri,\n      isActive: false,\n      exclusive,\n      injectedAt: Date.now(),\n    };\n    registerTrack(video, trackInfo);\n\n    // Setup cleanup handler if not already done\n    setupCleanup(video);\n\n    // Activate track if requested\n    if (activate) {\n      // Use setTimeout to ensure track is added to DOM before activation\n      setTimeout(() => {\n        activateTrack(video, track, exclusive);\n        trackInfo.isActive = true;\n      }, 0);\n    }\n\n    // Dispatch custom event for external listeners\n    video.dispatchEvent(new CustomEvent(TRACK_INJECTED_EVENT, {\n      detail: { track, label, language },\n    }));\n\n    log('info', `Track \"${label}\" injected successfully`);\n\n    return {\n      success: true,\n      track,\n      method: 'data-uri',\n    };\n  } catch (e) {\n    const error = e instanceof Error ? e.message : 'Unknown error';\n    log('error', `Track injection failed: ${error}`);\n    return {\n      success: false,\n      error,\n      method: 'data-uri',\n    };\n  }\n}\n\n/**\n * Inject a track using Blob URL (alternative method)\n *\n * @param video - Target video element\n * @param vttContent - VTT content string\n * @param options - Injection options\n * @returns Injection result\n */\nexport function injectTrackBlob(\n  video: HTMLVideoElement,\n  vttContent: string,\n  options: TrackInjectionOptions = {}\n): TrackInjectionResult {\n  const {\n    label = DEFAULT_LABEL,\n    language = DEFAULT_LANGUAGE,\n    kind = 'subtitles',\n    activate = true,\n    exclusive = true,\n  } = options;\n\n  log('info', `Injecting track via Blob URL: \"${label}\" (${language})`);\n\n  if (!video || !(video instanceof HTMLVideoElement)) {\n    log('error', 'Invalid video element');\n    return {\n      success: false,\n      error: 'Invalid video element',\n      method: 'blob-url',\n    };\n  }\n\n  // Check if we already injected a track with the same label\n  const existingTracks = getInjectedTracks(video);\n  const existingTrack = existingTracks.find((t) => t.label === label);\n  if (existingTrack) {\n    log('info', `Track \"${label}\" already exists, updating...`);\n    // Remove existing track and inject new one\n    removeTrack(video, existingTrack.element);\n  }\n\n  try {\n    // Create Blob URL\n    const blob = new Blob([vttContent], { type: 'text/vtt' });\n    const blobUrl = URL.createObjectURL(blob);\n\n    // Create track element\n    const track = document.createElement('track');\n    track.kind = kind;\n    track.label = label;\n    track.srclang = language;\n    track.src = blobUrl;\n    track.setAttribute(INJECTED_TRACK_ATTR, 'true');\n    track.setAttribute('data-blob-url', blobUrl); // Store for cleanup\n\n    // Add track to video\n    video.appendChild(track);\n\n    // Register track\n    const trackInfo: InjectedTrackInfo = {\n      element: track,\n      label,\n      language,\n      kind,\n      src: blobUrl,\n      isActive: false,\n      exclusive,\n      injectedAt: Date.now(),\n    };\n    registerTrack(video, trackInfo);\n\n    // Setup cleanup handler\n    setupCleanup(video);\n\n    // Activate if requested\n    if (activate) {\n      setTimeout(() => {\n        activateTrack(video, track, exclusive);\n        trackInfo.isActive = true;\n      }, 0);\n    }\n\n    video.dispatchEvent(new CustomEvent(TRACK_INJECTED_EVENT, {\n      detail: { track, label, language },\n    }));\n\n    log('info', `Track \"${label}\" injected via Blob URL successfully`);\n\n    return {\n      success: true,\n      track,\n      method: 'blob-url',\n    };\n  } catch (e) {\n    const error = e instanceof Error ? e.message : 'Unknown error';\n    log('error', `Blob URL track injection failed: ${error}`);\n    return {\n      success: false,\n      error,\n      method: 'blob-url',\n    };\n  }\n}\n\n/**\n * Inject a track using TextTrack API (programmatic approach)\n *\n * This method creates a <track> element with a minimal empty VTT, then uses\n * the TextTrack API to add cues programmatically. This ensures proper tracking\n * and cleanup while allowing dynamic cue management.\n *\n * @param video - Target video element\n * @param cues - Array of cue data [startTime, endTime, text]\n * @param options - Injection options\n * @returns Injection result\n */\nexport function injectTrackCues(\n  video: HTMLVideoElement,\n  cues: Array<{ startTime: number; endTime: number; text: string }>,\n  options: TrackInjectionOptions = {}\n): TrackInjectionResult {\n  const {\n    label = DEFAULT_LABEL,\n    language = DEFAULT_LANGUAGE,\n    kind = 'subtitles',\n    activate = true,\n    exclusive = true,\n  } = options;\n\n  log('info', `Injecting track via TextTrack API: \"${label}\" (${language}), ${cues.length} cues`);\n\n  if (!video || !(video instanceof HTMLVideoElement)) {\n    log('error', 'Invalid video element');\n    return {\n      success: false,\n      error: 'Invalid video element',\n      method: 'text-track-api',\n    };\n  }\n\n  // Check if we already injected a track with the same label\n  const existingTracks = getInjectedTracks(video);\n  const existingTrack = existingTracks.find((t) => t.label === label);\n  if (existingTrack) {\n    log('info', `Track \"${label}\" already exists, updating...`);\n    removeTrack(video, existingTrack.element);\n  }\n\n  try {\n    // Create a minimal empty VTT data URI for the track element\n    const emptyVttDataUri = 'data:text/vtt;charset=utf-8,' + encodeURIComponent('WEBVTT\\n\\n');\n\n    // Create track element\n    const track = document.createElement('track');\n    track.kind = kind;\n    track.label = label;\n    track.srclang = language;\n    track.src = emptyVttDataUri;\n    track.setAttribute(INJECTED_TRACK_ATTR, 'true');\n    track.setAttribute('data-injection-method', 'text-track-api');\n\n    // Register track info (before adding to DOM so it's tracked immediately)\n    const trackInfo: InjectedTrackInfo = {\n      element: track,\n      label,\n      language,\n      kind,\n      src: emptyVttDataUri,\n      isActive: false,\n      exclusive,\n      injectedAt: Date.now(),\n    };\n    registerTrack(video, trackInfo);\n\n    // Setup cleanup handler\n    setupCleanup(video);\n\n    // Add track to video\n    video.appendChild(track);\n\n    // Function to add cues and optionally activate\n    const addCuesAndActivate = () => {\n      const textTrack = track.track;\n      if (!textTrack) {\n        log('warn', `TextTrack not available for \"${label}\"`);\n        return;\n      }\n\n      // Add cues to the TextTrack\n      for (const cue of cues) {\n        const vttCue = new VTTCue(cue.startTime, cue.endTime, cue.text);\n        textTrack.addCue(vttCue);\n      }\n\n      log('debug', `Added ${cues.length} cues to track \"${label}\"`);\n\n      // Activate if requested\n      if (activate) {\n        if (exclusive) {\n          // Deactivate other tracks\n          const allTracks = getInjectedTracks(video);\n          for (let i = 0; i < video.textTracks.length; i++) {\n            const tt = video.textTracks[i];\n            if (tt !== textTrack && tt.mode === 'showing') {\n              tt.mode = 'disabled';\n              log('debug', `Deactivated track: \"${tt.label}\"`);\n              // Clear isActive flag for any injected track we disabled\n              const disabledTrackInfo = allTracks.find(\n                (t) => t.element.track === tt || (t.label === tt.label && t.language === tt.language)\n              );\n              if (disabledTrackInfo) {\n                disabledTrackInfo.isActive = false;\n              }\n            }\n          }\n        }\n        textTrack.mode = 'showing';\n        trackInfo.isActive = true;\n\n        // Dispatch activation event\n        video.dispatchEvent(new CustomEvent(TRACK_ACTIVATED_EVENT, {\n          detail: { track, label },\n        }));\n      }\n    };\n\n    // Add load handler to add cues after track loads\n    track.addEventListener('load', () => {\n      log('debug', `Track \"${label}\" loaded, adding cues`);\n      addCuesAndActivate();\n    }, { once: true });\n\n    track.addEventListener('error', (e) => {\n      log('error', `Track \"${label}\" failed to load:`, e);\n    }, { once: true });\n\n    // Dispatch custom event for external listeners\n    video.dispatchEvent(new CustomEvent(TRACK_INJECTED_EVENT, {\n      detail: { track, label, language },\n    }));\n\n    log('info', `Track \"${label}\" injected via TextTrack API with ${cues.length} cues`);\n\n    return {\n      success: true,\n      track,\n      method: 'text-track-api',\n    };\n  } catch (e) {\n    const error = e instanceof Error ? e.message : 'Unknown error';\n    log('error', `TextTrack API injection failed: ${error}`);\n    return {\n      success: false,\n      error,\n      method: 'text-track-api',\n    };\n  }\n}\n\n// ============================================\n// Track Activation/Deactivation\n// ============================================\n\n/**\n * Activate a track element\n *\n * @param video - Video element\n * @param track - Track element to activate\n * @param exclusive - Whether to deactivate other tracks\n */\nexport function activateTrack(\n  video: HTMLVideoElement,\n  track: HTMLTrackElement,\n  exclusive: boolean = true\n): void {\n  log('debug', `Activating track: \"${track.label}\"`);\n\n  // Find the corresponding TextTrack\n  const textTracks = video.textTracks;\n\n  // Deactivate other tracks if exclusive\n  if (exclusive) {\n    const allTracks = getInjectedTracks(video);\n    for (let i = 0; i < textTracks.length; i++) {\n      const tt = textTracks[i];\n      if (tt.label !== track.label && tt.mode === 'showing') {\n        tt.mode = 'disabled';\n        log('debug', `Deactivated track: \"${tt.label}\"`);\n        // Clear isActive flag for any injected track we disabled\n        const disabledTrackInfo = allTracks.find(\n          (t) => t.element.track === tt || (t.label === tt.label && t.language === tt.language)\n        );\n        if (disabledTrackInfo) {\n          disabledTrackInfo.isActive = false;\n        }\n      }\n    }\n  }\n\n  // Find and activate our track\n  for (let i = 0; i < textTracks.length; i++) {\n    const tt = textTracks[i];\n    if (tt.label === track.label && tt.language === track.srclang) {\n      tt.mode = 'showing';\n      log('info', `Track \"${track.label}\" activated`);\n\n      // Update our tracking\n      const tracks = getInjectedTracks(video);\n      const trackInfo = tracks.find((t) => t.element === track);\n      if (trackInfo) {\n        trackInfo.isActive = true;\n      }\n\n      // Dispatch activation event\n      video.dispatchEvent(new CustomEvent(TRACK_ACTIVATED_EVENT, {\n        detail: { track, label: track.label },\n      }));\n\n      // Try to notify Video.js about track change\n      notifyVideoJsTrackChange(video);\n\n      break;\n    }\n  }\n}\n\n/**\n * Deactivate a track element\n *\n * @param video - Video element\n * @param track - Track element to deactivate\n */\nexport function deactivateTrack(\n  video: HTMLVideoElement,\n  track: HTMLTrackElement\n): void {\n  log('debug', `Deactivating track: \"${track.label}\"`);\n\n  const textTracks = video.textTracks;\n\n  for (let i = 0; i < textTracks.length; i++) {\n    const tt = textTracks[i];\n    if (tt.label === track.label && tt.language === track.srclang) {\n      tt.mode = 'disabled';\n      log('info', `Track \"${track.label}\" deactivated`);\n\n      // Update our tracking\n      const tracks = getInjectedTracks(video);\n      const trackInfo = tracks.find((t) => t.element === track);\n      if (trackInfo) {\n        trackInfo.isActive = false;\n      }\n\n      break;\n    }\n  }\n}\n\n/**\n * Set track mode\n *\n * @param video - Video element\n * @param track - Track element\n * @param mode - Track mode\n */\nexport function setTrackMode(\n  video: HTMLVideoElement,\n  track: HTMLTrackElement,\n  mode: TrackMode\n): void {\n  const textTracks = video.textTracks;\n\n  for (let i = 0; i < textTracks.length; i++) {\n    const tt = textTracks[i];\n    if (tt.label === track.label && tt.language === track.srclang) {\n      tt.mode = mode;\n      log('debug', `Track \"${track.label}\" mode set to: ${mode}`);\n\n      // Update our tracking\n      const tracks = getInjectedTracks(video);\n      const trackInfo = tracks.find((t) => t.element === track);\n      if (trackInfo) {\n        trackInfo.isActive = mode === 'showing';\n      }\n\n      break;\n    }\n  }\n}\n\n/**\n * Try to notify Video.js about track changes\n * This may help update the CC menu in Video.js-based players\n */\nfunction notifyVideoJsTrackChange(video: HTMLVideoElement): void {\n  try {\n    // Dispatch texttrackchange event\n    const event = new Event('change', { bubbles: true });\n    video.textTracks.dispatchEvent(event);\n\n    // Also dispatch on video element\n    video.dispatchEvent(new Event('texttrackchange', { bubbles: true }));\n\n    log('debug', 'Video.js track change notification dispatched');\n  } catch (e) {\n    log('debug', 'Failed to notify Video.js:', e);\n  }\n}\n\n// ============================================\n// Track Removal & Cleanup\n// ============================================\n\n/**\n * Remove a track element from video\n *\n * @param video - Video element\n * @param track - Track element to remove\n */\nexport function removeTrack(\n  video: HTMLVideoElement,\n  track: HTMLTrackElement\n): void {\n  log('info', `Removing track: \"${track.label}\"`);\n\n  // Deactivate first\n  deactivateTrack(video, track);\n\n  // Revoke Blob URL if used\n  const blobUrl = track.getAttribute('data-blob-url');\n  if (blobUrl) {\n    try {\n      URL.revokeObjectURL(blobUrl);\n      log('debug', 'Blob URL revoked');\n    } catch (e) {\n      log('debug', 'Failed to revoke Blob URL:', e);\n    }\n  }\n\n  // Remove from DOM\n  track.remove();\n\n  // Unregister\n  unregisterTrack(video, track);\n\n  log('info', `Track \"${track.label}\" removed`);\n}\n\n/**\n * Remove all injected tracks from a video\n *\n * @param video - Video element\n */\nexport function removeAllTracks(video: HTMLVideoElement): void {\n  log('info', 'Removing all injected tracks');\n\n  // Make a copy of the array since removeTrack modifies it\n  const tracks = [...getInjectedTracks(video)];\n  const count = tracks.length;\n\n  for (const trackInfo of tracks) {\n    removeTrack(video, trackInfo.element);\n  }\n\n  log('info', `Removed ${count} tracks`);\n}\n\n/**\n * Setup cleanup handler for video element\n * Ensures tracks are cleaned up when video is removed from DOM\n */\nfunction setupCleanup(video: HTMLVideoElement): void {\n  if (cleanupHandlers.has(video)) {\n    return; // Already set up\n  }\n\n  // Use MutationObserver to detect when video is removed from DOM\n  const observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      for (const node of mutation.removedNodes) {\n        if (node === video || (node instanceof Element && node.contains(video))) {\n          log('debug', 'Video element removed from DOM, cleaning up tracks');\n          removeAllTracks(video);\n          observer.disconnect();\n          cleanupHandlers.delete(video);\n        }\n      }\n    }\n  });\n\n  // Observe parent element\n  const parent = video.parentElement;\n  if (parent) {\n    observer.observe(parent, { childList: true, subtree: true });\n  }\n\n  const cleanup = () => {\n    observer.disconnect();\n    removeAllTracks(video);\n  };\n\n  cleanupHandlers.set(video, cleanup);\n}\n\n// ============================================\n// Update Track Content\n// ============================================\n\n/**\n * Options for updating track content\n */\nexport interface TrackUpdateOptions {\n  /** Override the exclusive activation behavior (defaults to original track's setting) */\n  exclusive?: boolean;\n}\n\n/**\n * Update the content of an existing injected track\n *\n * @param video - Video element\n * @param trackOrLabel - Track element or label string\n * @param newContent - New VTT content\n * @param options - Update options (allows overriding exclusive behavior)\n * @returns Whether update was successful\n */\nexport function updateTrackContent(\n  video: HTMLVideoElement,\n  trackOrLabel: HTMLTrackElement | string,\n  newContent: string | VTTFile,\n  options: TrackUpdateOptions = {}\n): boolean {\n  const label = typeof trackOrLabel === 'string' ? trackOrLabel : trackOrLabel.label;\n\n  log('info', `Updating track content: \"${label}\"`);\n\n  const tracks = getInjectedTracks(video);\n  const trackInfo = tracks.find((t) => t.label === label);\n\n  if (!trackInfo) {\n    log('warn', `Track \"${label}\" not found`);\n    return false;\n  }\n\n  const wasActive = trackInfo.isActive;\n  // Preserve original exclusive setting unless overridden\n  const exclusive = options.exclusive ?? trackInfo.exclusive;\n\n  // Remove old track and inject new one\n  removeTrack(video, trackInfo.element);\n\n  const result = injectTrack(video, newContent, {\n    label,\n    language: trackInfo.language,\n    kind: trackInfo.kind,\n    activate: wasActive,\n    exclusive,\n  });\n\n  return result.success;\n}\n\n// ============================================\n// Query Functions\n// ============================================\n\n/**\n * Check if a video has any injected tracks\n */\nexport function hasInjectedTracks(video: HTMLVideoElement): boolean {\n  return getInjectedTracks(video).length > 0;\n}\n\n/**\n * Get the currently active injected track\n */\nexport function getActiveInjectedTrack(video: HTMLVideoElement): InjectedTrackInfo | null {\n  const tracks = getInjectedTracks(video);\n  return tracks.find((t) => t.isActive) || null;\n}\n\n/**\n * Find an injected track by label\n */\nexport function findTrackByLabel(\n  video: HTMLVideoElement,\n  label: string\n): InjectedTrackInfo | null {\n  const tracks = getInjectedTracks(video);\n  return tracks.find((t) => t.label === label) || null;\n}\n\n// ============================================\n// TrackInjector Class (OOP Interface)\n// ============================================\n\n/**\n * Object-oriented interface for track injection\n */\nexport class TrackInjector {\n  private video: HTMLVideoElement;\n  private defaultOptions: TrackInjectionOptions;\n\n  constructor(video: HTMLVideoElement, options: TrackInjectionOptions = {}) {\n    this.video = video;\n    this.defaultOptions = {\n      label: DEFAULT_LABEL,\n      language: DEFAULT_LANGUAGE,\n      kind: 'subtitles',\n      activate: true,\n      exclusive: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Inject a track\n   */\n  inject(vttContent: string | VTTFile, options?: TrackInjectionOptions): TrackInjectionResult {\n    return injectTrack(this.video, vttContent, { ...this.defaultOptions, ...options });\n  }\n\n  /**\n   * Inject using Blob URL\n   */\n  injectBlob(vttContent: string, options?: TrackInjectionOptions): TrackInjectionResult {\n    return injectTrackBlob(this.video, vttContent, { ...this.defaultOptions, ...options });\n  }\n\n  /**\n   * Inject using TextTrack API\n   */\n  injectCues(\n    cues: Array<{ startTime: number; endTime: number; text: string }>,\n    options?: TrackInjectionOptions\n  ): TrackInjectionResult {\n    return injectTrackCues(this.video, cues, { ...this.defaultOptions, ...options });\n  }\n\n  /**\n   * Get all injected tracks\n   */\n  getTracks(): InjectedTrackInfo[] {\n    return getInjectedTracks(this.video);\n  }\n\n  /**\n   * Get active track\n   */\n  getActiveTrack(): InjectedTrackInfo | null {\n    return getActiveInjectedTrack(this.video);\n  }\n\n  /**\n   * Activate a track by label\n   */\n  activateByLabel(label: string, exclusive: boolean = true): boolean {\n    const trackInfo = findTrackByLabel(this.video, label);\n    if (!trackInfo) {\n      return false;\n    }\n    activateTrack(this.video, trackInfo.element, exclusive);\n    return true;\n  }\n\n  /**\n   * Deactivate a track by label\n   */\n  deactivateByLabel(label: string): boolean {\n    const trackInfo = findTrackByLabel(this.video, label);\n    if (!trackInfo) {\n      return false;\n    }\n    deactivateTrack(this.video, trackInfo.element);\n    return true;\n  }\n\n  /**\n   * Update track content\n   */\n  update(label: string, newContent: string | VTTFile, options?: TrackUpdateOptions): boolean {\n    return updateTrackContent(this.video, label, newContent, options);\n  }\n\n  /**\n   * Remove a track by label\n   */\n  remove(label: string): boolean {\n    const trackInfo = findTrackByLabel(this.video, label);\n    if (!trackInfo) {\n      return false;\n    }\n    removeTrack(this.video, trackInfo.element);\n    return true;\n  }\n\n  /**\n   * Remove all injected tracks\n   */\n  removeAll(): void {\n    removeAllTracks(this.video);\n  }\n\n  /**\n   * Check if any tracks are injected\n   */\n  hasTracks(): boolean {\n    return hasInjectedTracks(this.video);\n  }\n\n  /**\n   * Get the video element\n   */\n  getVideo(): HTMLVideoElement {\n    return this.video;\n  }\n}\n\n// ============================================\n// Exports\n// ============================================\n\nexport default {\n  // Core functions\n  injectTrack,\n  injectTrackBlob,\n  injectTrackCues,\n  activateTrack,\n  deactivateTrack,\n  setTrackMode,\n  removeTrack,\n  removeAllTracks,\n  updateTrackContent,\n\n  // Query functions\n  getInjectedTracks,\n  hasInjectedTracks,\n  getActiveInjectedTrack,\n  findTrackByLabel,\n\n  // Utilities\n  setLogLevel,\n\n  // Class\n  TrackInjector,\n\n  // Constants\n  DEFAULT_LABEL,\n  DEFAULT_LANGUAGE,\n  INJECTED_TRACK_ATTR,\n  TRACK_INJECTED_EVENT,\n  TRACK_ACTIVATED_EVENT,\n};\n", "/**\n * Next Lecture Detector\n *\n * Task ID: T-20251223-act-011-build-preload\n *\n * Uses Udemy Curriculum API (preferred) to resolve the \"next lecture\" ID for the\n * current lecture page. Includes a best-effort UD global fallback.\n */\n\nexport interface NextLectureDetectionParams {\n  /** Course id used for cache key; may be numeric id or course slug */\n  courseId: string;\n  /** Course slug from URL */\n  courseSlug: string;\n  /** Current lecture id from URL */\n  currentLectureId: string;\n  /** Optional AbortSignal */\n  signal?: AbortSignal;\n}\n\nexport interface NextLectureDetectionResult {\n  /** Next lecture id if present */\n  nextLectureId: string | null;\n  /** Next lecture title if available */\n  nextLectureTitle?: string;\n  /** Whether current lecture is the last lecture in the course */\n  isLastLecture: boolean;\n  /** Detection method used */\n  method: 'curriculum-api' | 'ud-fallback' | 'none';\n  /** Error message (best-effort) */\n  error?: string;\n}\n\ntype CurriculumItem = {\n  _class?: string;\n  id?: number;\n  title?: string;\n  object_index?: number;\n  sort_order?: number;\n  is_published?: boolean;\n};\n\nconst LOG_PREFIX = '[UdemyCaptionPlus][NextLecture]';\n\nfunction log(...args: unknown[]): void {\n  // eslint-disable-next-line no-console\n  console.log(LOG_PREFIX, ...args);\n}\n\nfunction warn(...args: unknown[]): void {\n  // eslint-disable-next-line no-console\n  console.warn(LOG_PREFIX, ...args);\n}\n\nfunction isNumericId(value: string): boolean {\n  return /^\\d+$/.test(value);\n}\n\nfunction toCourseIdString(id: unknown): string | null {\n  if (typeof id === 'number' && Number.isFinite(id)) return String(id);\n  if (typeof id === 'string' && id.trim() !== '') return id.trim();\n  return null;\n}\n\nfunction getNumericCourseIdFromPage(): string | null {\n  // Method 1: UD global object\n  try {\n    const ud = (window as unknown as { UD?: any }).UD;\n    const candidates = [\n      ud?.config?.course?.id,\n      ud?.config?.brand?.course?.id,\n      ud?.course?.id,\n      ud?.courseTakingData?.courseId,\n      ud?.config?.lecture?.courseId,\n    ];\n\n    for (const candidate of candidates) {\n      const id = toCourseIdString(candidate);\n      if (id && isNumericId(id)) return id;\n    }\n  } catch {\n    // ignore\n  }\n\n  // Method 2: Performance entries (network requests)\n  try {\n    const entries = performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n    for (const entry of entries) {\n      const url = entry?.name;\n      if (typeof url !== 'string') continue;\n      const match = url.match(/api-2\\.0\\/courses\\/(\\d+)/) || url.match(/subscribed-courses\\/(\\d+)/);\n      if (match?.[1]) return match[1];\n    }\n  } catch {\n    // ignore\n  }\n\n  // Method 3: Data attribute\n  const courseElement = document.querySelector('[data-course-id]');\n  const courseId = courseElement?.getAttribute('data-course-id') || '';\n  if (courseId && isNumericId(courseId)) return courseId;\n\n  return null;\n}\n\nasync function resolveNumericCourseId(\n  params: Pick<NextLectureDetectionParams, 'courseId' | 'courseSlug' | 'signal'>\n): Promise<string | null> {\n  if (isNumericId(params.courseId)) return params.courseId;\n\n  const fromPage = getNumericCourseIdFromPage();\n  if (fromPage) return fromPage;\n\n  // Fallback: try resolving by slug (best-effort; may not work on all deployments)\n  try {\n    const url = `https://www.udemy.com/api-2.0/courses/${encodeURIComponent(params.courseSlug)}/?fields[course]=id`;\n    const response = await fetch(url, { credentials: 'include', signal: params.signal });\n    if (!response.ok) return null;\n    const data = (await response.json()) as { id?: number | string } | null;\n    const id = toCourseIdString(data?.id);\n    if (id && isNumericId(id)) return id;\n  } catch {\n    // ignore\n  }\n\n  return null;\n}\n\nfunction getNextLectureIdFromUD(): { id: string; title?: string } | null {\n  try {\n    const ud = (window as unknown as { UD?: any }).UD;\n    const candidates: Array<() => unknown> = [\n      () => ud?.lecture?.nextLecture?.id,\n      () => ud?.lectureInfo?.next?.id,\n      () => ud?.courseTakingData?.nextLecture?.id,\n      () => ud?.config?.lecture?.next?.id,\n      () => ud?.videoPlayer?.nextLecture?.id,\n      () => ud?.data?.nextLectureId,\n    ];\n\n    for (const fn of candidates) {\n      const raw = fn();\n      const id = toCourseIdString(raw);\n      if (id && isNumericId(id)) {\n        const title = toCourseIdString(ud?.lecture?.nextLecture?.title) || undefined;\n        return { id, title };\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  return null;\n}\n\nasync function fetchCurriculumNextLecture(params: NextLectureDetectionParams): Promise<NextLectureDetectionResult> {\n  const numericCourseId = await resolveNumericCourseId(params);\n  if (!numericCourseId) {\n    return {\n      nextLectureId: null,\n      isLastLecture: false,\n      method: 'none',\n      error: 'Unable to resolve numeric courseId for curriculum API',\n    };\n  }\n\n  const apiUrl =\n    `https://www.udemy.com/api-2.0/courses/${numericCourseId}/subscriber-curriculum-items/` +\n    `?page_size=1400` +\n    `&fields[lecture]=title,object_index,is_published,sort_order` +\n    `&fields[chapter]=title,object_index` +\n    `&fields[quiz]=title,object_index` +\n    `&fields[practice]=title,object_index` +\n    `&caching_intent=True`;\n\n  try {\n    const response = await fetch(apiUrl, { credentials: 'include', signal: params.signal });\n    if (!response.ok) {\n      return {\n        nextLectureId: null,\n        isLastLecture: false,\n        method: 'none',\n        error: `Curriculum API request failed: ${response.status}`,\n      };\n    }\n\n    const data = (await response.json()) as { results?: CurriculumItem[] } | null;\n    const items = Array.isArray(data?.results) ? data!.results! : [];\n\n    const lectures = items\n      .filter((item) => item && item._class === 'lecture' && item.is_published !== false)\n      .filter((item) => typeof item.id === 'number')\n      .slice()\n      .sort((a, b) => {\n        const aIdx = typeof a.object_index === 'number' ? a.object_index : typeof a.sort_order === 'number' ? a.sort_order : 0;\n        const bIdx = typeof b.object_index === 'number' ? b.object_index : typeof b.sort_order === 'number' ? b.sort_order : 0;\n        return aIdx - bIdx;\n      });\n\n    const currentIndex = lectures.findIndex((l) => String(l.id) === params.currentLectureId);\n    if (currentIndex < 0) {\n      return {\n        nextLectureId: null,\n        isLastLecture: false,\n        method: 'none',\n        error: 'Current lecture not found in curriculum',\n      };\n    }\n\n    if (currentIndex >= lectures.length - 1) {\n      return {\n        nextLectureId: null,\n        isLastLecture: true,\n        method: 'curriculum-api',\n      };\n    }\n\n    const next = lectures[currentIndex + 1];\n    return {\n      nextLectureId: String(next.id),\n      nextLectureTitle: typeof next.title === 'string' ? next.title : undefined,\n      isLastLecture: false,\n      method: 'curriculum-api',\n    };\n  } catch (error) {\n    return {\n      nextLectureId: null,\n      isLastLecture: false,\n      method: 'none',\n      error: String(error),\n    };\n  }\n}\n\n/**\n * Detect the next lecture ID for the current lecture.\n */\nexport async function detectNextLecture(\n  params: NextLectureDetectionParams\n): Promise<NextLectureDetectionResult> {\n  // Prefer Curriculum API for cross-section correctness.\n  const viaApi = await fetchCurriculumNextLecture(params);\n  if (viaApi.method === 'curriculum-api' && (viaApi.nextLectureId || viaApi.isLastLecture)) {\n    log('Resolved via curriculum API:', viaApi.nextLectureId || '(last lecture)');\n    return viaApi;\n  }\n\n  const udNext = getNextLectureIdFromUD();\n  if (udNext) {\n    log('Resolved via UD fallback:', udNext.id);\n    return {\n      nextLectureId: udNext.id,\n      nextLectureTitle: udNext.title,\n      isLastLecture: false,\n      method: 'ud-fallback',\n    };\n  }\n\n  if (viaApi.error) warn('Failed to resolve via API:', viaApi.error);\n  return {\n    nextLectureId: null,\n    isLastLecture: false,\n    method: 'none',\n    error: viaApi.error,\n  };\n}\n\n", "/**\n * Settings Manager for Udemy \u5B57\u5E55\u589E\u5F3A\n * Task ID: T-20251223-act-009-build-popup-settings\n *\n * Provides a unified interface for reading and writing user settings\n * using chrome.storage.sync. Can be used by popup, content script,\n * and service worker.\n */\n\nimport type { UserSettings } from '../types';\n\n// ============================================\n// Constants\n// ============================================\n\n/**\n * Default settings\n */\nexport const DEFAULT_SETTINGS: UserSettings = {\n  provider: 'openai',\n  apiKey: '',\n  model: 'gpt-5.1',\n  enabled: true,\n  autoTranslate: true,\n  preloadEnabled: true,\n  showCostEstimate: true,\n  showLoadingIndicator: true,\n};\n\n/**\n * Available models for each provider\n */\nexport const PROVIDER_MODELS: Record<string, { value: string; label: string; costPer1kTokens: number }[]> = {\n  openai: [\n    { value: 'gpt-5.2', label: 'GPT-5.2', costPer1kTokens: 0.01 },\n    { value: 'gpt-5.1', label: 'GPT-5.1', costPer1kTokens: 0.008 },\n    { value: 'gpt-5-pro', label: 'GPT-5 Pro', costPer1kTokens: 0.015 },\n    { value: 'gpt-5', label: 'GPT-5', costPer1kTokens: 0.006 },\n  ],\n  gemini: [\n    { value: 'gemini-3-pro-preview', label: 'Gemini 3 Pro Preview', costPer1kTokens: 0.005 },\n    { value: 'gemini-3-flash-preview', label: 'Gemini 3 Flash Preview', costPer1kTokens: 0.001 },\n    { value: 'gemini-2.5-pro', label: 'Gemini 2.5 Pro', costPer1kTokens: 0.003 },\n    { value: 'gemini-2.5-flash', label: 'Gemini 2.5 Flash', costPer1kTokens: 0.0005 },\n  ],\n};\n\n/**\n * Storage key for settings\n */\nconst STORAGE_KEY = 'udemy-caption-settings';\n\n// ============================================\n// Type Guards\n// ============================================\n\n/**\n * Check if running in Chrome extension context\n */\nfunction isChromeExtension(): boolean {\n  return typeof chrome !== 'undefined' && !!chrome.storage?.sync;\n}\n\n// ============================================\n// Storage Operations\n// ============================================\n\n/**\n * Load settings from storage\n * Uses chrome.storage.sync in extension context, localStorage as fallback\n */\nexport async function loadSettings(): Promise<UserSettings> {\n  return new Promise((resolve) => {\n    if (isChromeExtension()) {\n      chrome.storage.sync.get(DEFAULT_SETTINGS, (result) => {\n        resolve(result as UserSettings);\n      });\n    } else {\n      // Fallback for development/testing\n      const stored = localStorage.getItem(STORAGE_KEY);\n      if (stored) {\n        try {\n          resolve({ ...DEFAULT_SETTINGS, ...JSON.parse(stored) });\n        } catch {\n          resolve(DEFAULT_SETTINGS);\n        }\n      } else {\n        resolve(DEFAULT_SETTINGS);\n      }\n    }\n  });\n}\n\n/**\n * Save settings to storage\n * Uses chrome.storage.sync in extension context, localStorage as fallback\n */\nexport async function saveSettings(settings: Partial<UserSettings>): Promise<void> {\n  return new Promise((resolve, reject) => {\n    if (isChromeExtension()) {\n      chrome.storage.sync.set(settings, () => {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message));\n        } else {\n          resolve();\n        }\n      });\n    } else {\n      // Fallback for development/testing\n      try {\n        const current = localStorage.getItem(STORAGE_KEY);\n        const merged = { ...(current ? JSON.parse(current) : DEFAULT_SETTINGS), ...settings };\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(merged));\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    }\n  });\n}\n\n/**\n * Clear all settings and reset to defaults\n */\nexport async function resetSettings(): Promise<void> {\n  return saveSettings(DEFAULT_SETTINGS);\n}\n\n/**\n * Get a single setting value\n */\nexport async function getSetting<K extends keyof UserSettings>(key: K): Promise<UserSettings[K]> {\n  const settings = await loadSettings();\n  return settings[key];\n}\n\n/**\n * Set a single setting value\n */\nexport async function setSetting<K extends keyof UserSettings>(\n  key: K,\n  value: UserSettings[K]\n): Promise<void> {\n  return saveSettings({ [key]: value });\n}\n\n// ============================================\n// Settings Change Listener\n// ============================================\n\ntype SettingsChangeCallback = (newSettings: UserSettings, oldSettings: UserSettings) => void;\n\nconst changeListeners: Set<SettingsChangeCallback> = new Set();\n\n/**\n * Subscribe to settings changes\n * Returns an unsubscribe function\n */\nexport function onSettingsChange(callback: SettingsChangeCallback): () => void {\n  changeListeners.add(callback);\n\n  // Set up chrome.storage listener if in extension context\n  if (isChromeExtension() && changeListeners.size === 1) {\n    chrome.storage.onChanged.addListener(handleStorageChange);\n  }\n\n  return () => {\n    changeListeners.delete(callback);\n    if (isChromeExtension() && changeListeners.size === 0) {\n      chrome.storage.onChanged.removeListener(handleStorageChange);\n    }\n  };\n}\n\n/**\n * Handle chrome.storage change events\n */\nfunction handleStorageChange(\n  changes: { [key: string]: chrome.storage.StorageChange },\n  areaName: string\n): void {\n  if (areaName !== 'sync') return;\n\n  // Build old and new settings objects\n  const oldSettings: Partial<UserSettings> = {};\n  const newSettings: Partial<UserSettings> = {};\n\n  for (const key of Object.keys(changes) as Array<keyof UserSettings>) {\n    if (key in DEFAULT_SETTINGS) {\n      oldSettings[key] = changes[key].oldValue;\n      newSettings[key] = changes[key].newValue;\n    }\n  }\n\n  // Notify listeners\n  loadSettings().then((currentSettings) => {\n    const previousSettings = { ...currentSettings };\n    for (const key of Object.keys(oldSettings) as Array<keyof UserSettings>) {\n      if (oldSettings[key] !== undefined) {\n        (previousSettings as Record<string, unknown>)[key] = oldSettings[key];\n      }\n    }\n\n    for (const listener of changeListeners) {\n      try {\n        listener(currentSettings, previousSettings);\n      } catch (error) {\n        console.error('[SettingsManager] Error in change listener:', error);\n      }\n    }\n  });\n}\n\n// ============================================\n// Utility Functions\n// ============================================\n\n/**\n * Check if settings are valid for translation\n */\nexport function isConfigured(settings: UserSettings): boolean {\n  return !!settings.apiKey && !!settings.model && !!settings.provider;\n}\n\n/**\n * Check if translation is enabled\n */\nexport function isEnabled(settings: UserSettings): boolean {\n  return settings.enabled && isConfigured(settings);\n}\n\n/**\n * Get model info for the current settings\n */\nexport function getModelInfo(settings: UserSettings): {\n  label: string;\n  costPer1kTokens: number;\n} | null {\n  const models = PROVIDER_MODELS[settings.provider];\n  if (!models) return null;\n\n  const model = models.find((m) => m.value === settings.model);\n  return model ? { label: model.label, costPer1kTokens: model.costPer1kTokens } : null;\n}\n\n/**\n * Estimate cost for a given number of tokens\n */\nexport function estimateCost(settings: UserSettings, tokenCount: number): number {\n  const modelInfo = getModelInfo(settings);\n  if (!modelInfo) return 0;\n\n  return (tokenCount / 1000) * modelInfo.costPer1kTokens;\n}\n\n// ============================================\n// Export SettingsManager class for OOP usage\n// ============================================\n\n/**\n * Settings Manager class for object-oriented usage\n */\nexport class SettingsManager {\n  private cachedSettings: UserSettings | null = null;\n  private unsubscribe: (() => void) | null = null;\n\n  /**\n   * Initialize the settings manager\n   */\n  async init(): Promise<UserSettings> {\n    this.cachedSettings = await loadSettings();\n\n    // Subscribe to changes to keep cache updated\n    this.unsubscribe = onSettingsChange((newSettings) => {\n      this.cachedSettings = newSettings;\n    });\n\n    return this.cachedSettings;\n  }\n\n  /**\n   * Get current settings (from cache if available)\n   */\n  async getSettings(): Promise<UserSettings> {\n    if (this.cachedSettings) {\n      return this.cachedSettings;\n    }\n    return loadSettings();\n  }\n\n  /**\n   * Update settings\n   */\n  async updateSettings(settings: Partial<UserSettings>): Promise<void> {\n    await saveSettings(settings);\n    if (this.cachedSettings) {\n      this.cachedSettings = { ...this.cachedSettings, ...settings };\n    }\n  }\n\n  /**\n   * Check if translation is enabled\n   */\n  isEnabled(): boolean {\n    if (!this.cachedSettings) return false;\n    return isEnabled(this.cachedSettings);\n  }\n\n  /**\n   * Check if settings are configured\n   */\n  isConfigured(): boolean {\n    if (!this.cachedSettings) return false;\n    return isConfigured(this.cachedSettings);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = null;\n    }\n    this.cachedSettings = null;\n  }\n}\n\n// Export singleton instance\nexport const settingsManager = new SettingsManager();\n", "/**\n * Loading Indicator Module\n *\n * Displays translation status overlay on video player.\n * Follows Udemy's visual style with purple accent (#a435f0).\n *\n * Task ID: T-20251223-act-013-build-loading-indicator\n */\n\n// ============================================\n// Types\n// ============================================\n\nexport type IndicatorStatus = 'loading' | 'success' | 'error' | 'hidden';\n\nexport interface IndicatorOptions {\n  /** Status message to display */\n  message?: string;\n  /** Error details for error status */\n  errorDetails?: string;\n  /** Retry callback for error status */\n  onRetry?: () => void;\n  /** Auto-hide delay in ms (default: 3000 for success, 0 for others) */\n  autoHideDelay?: number;\n  /** Position relative to video (default: 'top-right') */\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'center';\n}\n\ninterface IndicatorState {\n  status: IndicatorStatus;\n  message: string;\n  errorDetails?: string;\n  onRetry?: () => void;\n}\n\n// ============================================\n// Constants\n// ============================================\n\nconst INDICATOR_ID = 'udemy-caption-plus-loading-indicator';\nconst INDICATOR_CLASS = 'ucp-loading-indicator';\n\n/** CSS for the loading indicator - matches Udemy's style */\nconst INDICATOR_STYLES = `\n.${INDICATOR_CLASS} {\n  position: absolute;\n  z-index: 100000;\n  padding: 10px 16px;\n  border-radius: 6px;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n  font-size: 13px;\n  line-height: 1.4;\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  transition: opacity 0.3s ease, transform 0.3s ease;\n  pointer-events: auto;\n  max-width: 320px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n}\n\n.${INDICATOR_CLASS}--hidden {\n  opacity: 0;\n  pointer-events: none;\n  transform: translateY(-10px);\n}\n\n/* Position variants */\n.${INDICATOR_CLASS}--top-left {\n  top: 12px;\n  left: 12px;\n}\n\n.${INDICATOR_CLASS}--top-right {\n  top: 12px;\n  right: 12px;\n}\n\n.${INDICATOR_CLASS}--bottom-left {\n  bottom: 60px;\n  left: 12px;\n}\n\n.${INDICATOR_CLASS}--bottom-right {\n  bottom: 60px;\n  right: 12px;\n}\n\n.${INDICATOR_CLASS}--center {\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.${INDICATOR_CLASS}--center.${INDICATOR_CLASS}--hidden {\n  opacity: 0;\n  transform: translate(-50%, -50%) scale(0.95);\n}\n\n/* Status variants */\n.${INDICATOR_CLASS}--loading {\n  background: rgba(164, 53, 240, 0.95);\n  color: #fff;\n}\n\n.${INDICATOR_CLASS}--success {\n  background: rgba(46, 125, 50, 0.95);\n  color: #fff;\n}\n\n.${INDICATOR_CLASS}--error {\n  background: rgba(198, 40, 40, 0.95);\n  color: #fff;\n  flex-direction: column;\n  align-items: flex-start;\n}\n\n/* Spinner animation */\n.${INDICATOR_CLASS}__spinner {\n  width: 16px;\n  height: 16px;\n  border: 2px solid rgba(255, 255, 255, 0.3);\n  border-top-color: #fff;\n  border-radius: 50%;\n  animation: ucp-spin 0.8s linear infinite;\n  flex-shrink: 0;\n}\n\n@keyframes ucp-spin {\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n/* Check icon for success */\n.${INDICATOR_CLASS}__check {\n  width: 16px;\n  height: 16px;\n  border-radius: 50%;\n  background: #fff;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n}\n\n.${INDICATOR_CLASS}__check::after {\n  content: \"\";\n  width: 4px;\n  height: 8px;\n  border: solid #2e7d32;\n  border-width: 0 2px 2px 0;\n  transform: rotate(45deg);\n  margin-top: -2px;\n}\n\n/* Error icon */\n.${INDICATOR_CLASS}__error-icon {\n  width: 16px;\n  height: 16px;\n  border-radius: 50%;\n  background: #fff;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n}\n\n.${INDICATOR_CLASS}__error-icon::after {\n  content: \"!\";\n  color: #c62828;\n  font-size: 12px;\n  font-weight: bold;\n}\n\n/* Message text */\n.${INDICATOR_CLASS}__message {\n  flex: 1;\n}\n\n/* Error details */\n.${INDICATOR_CLASS}__details {\n  font-size: 11px;\n  opacity: 0.85;\n  margin-top: 4px;\n  word-break: break-word;\n}\n\n/* Error actions row */\n.${INDICATOR_CLASS}__actions {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  margin-top: 8px;\n  width: 100%;\n}\n\n/* Retry button */\n.${INDICATOR_CLASS}__retry-btn {\n  padding: 6px 12px;\n  font-size: 12px;\n  font-weight: 500;\n  background: rgba(255, 255, 255, 0.2);\n  color: #fff;\n  border: 1px solid rgba(255, 255, 255, 0.4);\n  border-radius: 4px;\n  cursor: pointer;\n  transition: background 0.2s;\n}\n\n.${INDICATOR_CLASS}__retry-btn:hover {\n  background: rgba(255, 255, 255, 0.3);\n}\n\n.${INDICATOR_CLASS}__retry-btn:active {\n  transform: scale(0.98);\n}\n\n/* Dismiss button */\n.${INDICATOR_CLASS}__dismiss-btn {\n  padding: 6px 12px;\n  font-size: 12px;\n  background: transparent;\n  color: rgba(255, 255, 255, 0.8);\n  border: none;\n  cursor: pointer;\n  transition: color 0.2s;\n}\n\n.${INDICATOR_CLASS}__dismiss-btn:hover {\n  color: #fff;\n}\n`;\n\n// ============================================\n// State Management\n// ============================================\n\n/** WeakMap to track indicator state per video element */\nconst indicatorStates = new WeakMap<HTMLVideoElement, IndicatorState>();\n\n/** WeakMap to track indicator elements per video element */\nconst indicatorElements = new WeakMap<HTMLVideoElement, HTMLElement>();\n\n/** WeakMap to track auto-hide timers */\nconst autoHideTimers = new WeakMap<HTMLVideoElement, ReturnType<typeof setTimeout>>();\n\n/** Style element reference */\nlet styleElement: HTMLStyleElement | null = null;\n\n// ============================================\n// Style Injection\n// ============================================\n\n/**\n * Injects CSS styles for the loading indicator into the document\n */\nfunction ensureStylesInjected(): void {\n  if (styleElement && document.head.contains(styleElement)) {\n    return;\n  }\n\n  styleElement = document.createElement('style');\n  styleElement.id = `${INDICATOR_ID}-styles`;\n  styleElement.textContent = INDICATOR_STYLES;\n  document.head.appendChild(styleElement);\n}\n\n// ============================================\n// DOM Helpers\n// ============================================\n\n/**\n * Creates the indicator DOM element\n */\nfunction createIndicatorElement(\n  state: IndicatorState,\n  position: NonNullable<IndicatorOptions['position']>\n): HTMLElement {\n  const container = document.createElement('div');\n  // Note: No ID is assigned to avoid duplicate IDs when multiple videos exist on the page.\n  // Indicators are tracked per-video via WeakMap and styled via classes.\n  container.className = `${INDICATOR_CLASS} ${INDICATOR_CLASS}--${position}`;\n\n  updateIndicatorDOM(container, state);\n  return container;\n}\n\n/**\n * Updates the indicator DOM based on current state\n */\nfunction updateIndicatorDOM(container: HTMLElement, state: IndicatorState): void {\n  const { status, message, errorDetails, onRetry } = state;\n\n  // Update status class\n  container.classList.remove(\n    `${INDICATOR_CLASS}--loading`,\n    `${INDICATOR_CLASS}--success`,\n    `${INDICATOR_CLASS}--error`,\n    `${INDICATOR_CLASS}--hidden`\n  );\n\n  if (status === 'hidden') {\n    container.classList.add(`${INDICATOR_CLASS}--hidden`);\n    return;\n  }\n\n  container.classList.add(`${INDICATOR_CLASS}--${status}`);\n\n  // Build content based on status\n  let html = '';\n\n  if (status === 'loading') {\n    html = `\n      <div class=\"${INDICATOR_CLASS}__spinner\"></div>\n      <span class=\"${INDICATOR_CLASS}__message\">${escapeHtml(message)}</span>\n    `;\n  } else if (status === 'success') {\n    html = `\n      <div class=\"${INDICATOR_CLASS}__check\"></div>\n      <span class=\"${INDICATOR_CLASS}__message\">${escapeHtml(message)}</span>\n    `;\n  } else if (status === 'error') {\n    html = `\n      <div style=\"display: flex; align-items: center; gap: 10px; width: 100%;\">\n        <div class=\"${INDICATOR_CLASS}__error-icon\"></div>\n        <span class=\"${INDICATOR_CLASS}__message\">${escapeHtml(message)}</span>\n      </div>\n      ${errorDetails ? `<div class=\"${INDICATOR_CLASS}__details\">${escapeHtml(errorDetails)}</div>` : ''}\n      <div class=\"${INDICATOR_CLASS}__actions\">\n        ${onRetry ? `<button class=\"${INDICATOR_CLASS}__retry-btn\" type=\"button\">\u91CD\u8BD5</button>` : ''}\n        <button class=\"${INDICATOR_CLASS}__dismiss-btn\" type=\"button\">\u5173\u95ED</button>\n      </div>\n    `;\n  }\n\n  container.innerHTML = html;\n\n  // Attach event listeners\n  if (status === 'error') {\n    const retryBtn = container.querySelector(`.${INDICATOR_CLASS}__retry-btn`);\n    const dismissBtn = container.querySelector(`.${INDICATOR_CLASS}__dismiss-btn`);\n\n    if (retryBtn && onRetry) {\n      retryBtn.addEventListener('click', () => {\n        onRetry();\n      });\n    }\n\n    if (dismissBtn) {\n      dismissBtn.addEventListener('click', () => {\n        container.classList.add(`${INDICATOR_CLASS}--hidden`);\n      });\n    }\n  }\n}\n\n/**\n * Escapes HTML special characters to prevent XSS\n */\nfunction escapeHtml(text: string): string {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n/**\n * Finds the video container element for positioning\n */\nfunction findVideoContainer(video: HTMLVideoElement): HTMLElement {\n  // Try common Udemy video container selectors\n  const selectors = [\n    '[data-purpose=\"video-player\"]',\n    '[class*=\"video-player--container--\"]',\n    '.vjs-tech',\n    '.video-js',\n  ];\n\n  for (const selector of selectors) {\n    const container = video.closest(selector);\n    if (container instanceof HTMLElement) {\n      return container;\n    }\n  }\n\n  // Fallback to video's parent\n  return video.parentElement || document.body;\n}\n\n// ============================================\n// Public API\n// ============================================\n\n/**\n * Shows the loading indicator on a video element\n *\n * @param video - The video element to attach the indicator to\n * @param options - Display options\n */\nexport function showLoadingIndicator(\n  video: HTMLVideoElement,\n  options: IndicatorOptions = {}\n): void {\n  const {\n    message = '\u5B57\u5E55\u7FFB\u8BD1\u4E2D\u2026',\n    position = 'top-right',\n    autoHideDelay = 0,\n  } = options;\n\n  ensureStylesInjected();\n\n  const state: IndicatorState = {\n    status: 'loading',\n    message,\n  };\n\n  indicatorStates.set(video, state);\n\n  // Clear any existing auto-hide timer\n  const existingTimer = autoHideTimers.get(video);\n  if (existingTimer) {\n    clearTimeout(existingTimer);\n    autoHideTimers.delete(video);\n  }\n\n  // Get or create indicator element\n  let indicator = indicatorElements.get(video);\n  const container = findVideoContainer(video);\n\n  if (!indicator || !container.contains(indicator)) {\n    indicator = createIndicatorElement(state, position);\n    indicatorElements.set(video, indicator);\n\n    // Ensure container has relative positioning for absolute child\n    const containerStyle = window.getComputedStyle(container);\n    if (containerStyle.position === 'static') {\n      container.style.position = 'relative';\n    }\n\n    container.appendChild(indicator);\n\n    // Trigger reflow for animation\n    void indicator.offsetHeight;\n  } else {\n    // Update position class\n    indicator.className = `${INDICATOR_CLASS} ${INDICATOR_CLASS}--${position}`;\n    updateIndicatorDOM(indicator, state);\n  }\n\n  // Set up auto-hide if specified\n  if (autoHideDelay > 0) {\n    const timer = setTimeout(() => {\n      hideLoadingIndicator(video);\n    }, autoHideDelay);\n    autoHideTimers.set(video, timer);\n  }\n}\n\n/**\n * Shows a success message on the indicator\n *\n * @param video - The video element\n * @param options - Display options\n */\nexport function showSuccessIndicator(\n  video: HTMLVideoElement,\n  options: IndicatorOptions = {}\n): void {\n  const {\n    message = '\u7FFB\u8BD1\u5B8C\u6210',\n    position = 'top-right',\n    autoHideDelay = 3000,\n  } = options;\n\n  ensureStylesInjected();\n\n  const state: IndicatorState = {\n    status: 'success',\n    message,\n  };\n\n  indicatorStates.set(video, state);\n\n  // Clear any existing auto-hide timer\n  const existingTimer = autoHideTimers.get(video);\n  if (existingTimer) {\n    clearTimeout(existingTimer);\n    autoHideTimers.delete(video);\n  }\n\n  // Get or create indicator element\n  let indicator = indicatorElements.get(video);\n  const container = findVideoContainer(video);\n\n  if (!indicator || !container.contains(indicator)) {\n    indicator = createIndicatorElement(state, position);\n    indicatorElements.set(video, indicator);\n\n    const containerStyle = window.getComputedStyle(container);\n    if (containerStyle.position === 'static') {\n      container.style.position = 'relative';\n    }\n\n    container.appendChild(indicator);\n    void indicator.offsetHeight;\n  } else {\n    indicator.className = `${INDICATOR_CLASS} ${INDICATOR_CLASS}--${position}`;\n    updateIndicatorDOM(indicator, state);\n  }\n\n  // Set up auto-hide\n  if (autoHideDelay > 0) {\n    const timer = setTimeout(() => {\n      hideLoadingIndicator(video);\n    }, autoHideDelay);\n    autoHideTimers.set(video, timer);\n  }\n}\n\n/**\n * Shows an error message on the indicator with optional retry button\n *\n * @param video - The video element\n * @param options - Display options including error details and retry callback\n */\nexport function showErrorIndicator(\n  video: HTMLVideoElement,\n  options: IndicatorOptions = {}\n): void {\n  const {\n    message = '\u7FFB\u8BD1\u5931\u8D25',\n    errorDetails,\n    onRetry,\n    position = 'top-right',\n    autoHideDelay = 0,\n  } = options;\n\n  ensureStylesInjected();\n\n  const state: IndicatorState = {\n    status: 'error',\n    message,\n    errorDetails,\n    onRetry,\n  };\n\n  indicatorStates.set(video, state);\n\n  // Clear any existing auto-hide timer\n  const existingTimer = autoHideTimers.get(video);\n  if (existingTimer) {\n    clearTimeout(existingTimer);\n    autoHideTimers.delete(video);\n  }\n\n  // Get or create indicator element\n  let indicator = indicatorElements.get(video);\n  const container = findVideoContainer(video);\n\n  if (!indicator || !container.contains(indicator)) {\n    indicator = createIndicatorElement(state, position);\n    indicatorElements.set(video, indicator);\n\n    const containerStyle = window.getComputedStyle(container);\n    if (containerStyle.position === 'static') {\n      container.style.position = 'relative';\n    }\n\n    container.appendChild(indicator);\n    void indicator.offsetHeight;\n  } else {\n    indicator.className = `${INDICATOR_CLASS} ${INDICATOR_CLASS}--${position}`;\n    updateIndicatorDOM(indicator, state);\n  }\n\n  // Set up auto-hide if specified (usually 0 for errors to require user action)\n  if (autoHideDelay > 0) {\n    const timer = setTimeout(() => {\n      hideLoadingIndicator(video);\n    }, autoHideDelay);\n    autoHideTimers.set(video, timer);\n  }\n}\n\n/**\n * Hides the loading indicator for a video element\n *\n * @param video - The video element\n */\nexport function hideLoadingIndicator(video: HTMLVideoElement): void {\n  const indicator = indicatorElements.get(video);\n  if (!indicator) return;\n\n  // Clear any auto-hide timer\n  const timer = autoHideTimers.get(video);\n  if (timer) {\n    clearTimeout(timer);\n    autoHideTimers.delete(video);\n  }\n\n  // Animate out\n  indicator.classList.add(`${INDICATOR_CLASS}--hidden`);\n\n  // Update state\n  const state = indicatorStates.get(video);\n  if (state) {\n    state.status = 'hidden';\n  }\n}\n\n/**\n * Removes the loading indicator element from DOM\n *\n * @param video - The video element\n */\nexport function removeLoadingIndicator(video: HTMLVideoElement): void {\n  const indicator = indicatorElements.get(video);\n  if (indicator) {\n    indicator.remove();\n    indicatorElements.delete(video);\n  }\n\n  indicatorStates.delete(video);\n\n  const timer = autoHideTimers.get(video);\n  if (timer) {\n    clearTimeout(timer);\n    autoHideTimers.delete(video);\n  }\n}\n\n/**\n * Gets the current indicator status for a video\n *\n * @param video - The video element\n * @returns Current status or 'hidden' if no indicator exists\n */\nexport function getIndicatorStatus(video: HTMLVideoElement): IndicatorStatus {\n  const state = indicatorStates.get(video);\n  return state?.status ?? 'hidden';\n}\n\n/**\n * Checks if an indicator is currently visible\n *\n * @param video - The video element\n * @returns True if indicator is visible (not hidden)\n */\nexport function isIndicatorVisible(video: HTMLVideoElement): boolean {\n  const status = getIndicatorStatus(video);\n  return status !== 'hidden';\n}\n\n/**\n * Updates the loading message while keeping the loading state\n *\n * @param video - The video element\n * @param message - New message to display\n */\nexport function updateLoadingMessage(video: HTMLVideoElement, message: string): void {\n  const state = indicatorStates.get(video);\n  if (!state || state.status !== 'loading') return;\n\n  state.message = message;\n\n  const indicator = indicatorElements.get(video);\n  if (indicator) {\n    updateIndicatorDOM(indicator, state);\n  }\n}\n\n// ============================================\n// Class-based API\n// ============================================\n\n/**\n * Class-based wrapper for managing loading indicators\n */\nexport class LoadingIndicator {\n  private video: HTMLVideoElement;\n  private defaultPosition: NonNullable<IndicatorOptions['position']>;\n\n  constructor(\n    video: HTMLVideoElement,\n    options: { position?: IndicatorOptions['position'] } = {}\n  ) {\n    this.video = video;\n    this.defaultPosition = options.position ?? 'top-right';\n  }\n\n  /**\n   * Shows loading state\n   */\n  showLoading(message?: string): void {\n    showLoadingIndicator(this.video, {\n      message,\n      position: this.defaultPosition,\n    });\n  }\n\n  /**\n   * Shows success state with auto-hide\n   */\n  showSuccess(message?: string, autoHideDelay?: number): void {\n    showSuccessIndicator(this.video, {\n      message,\n      position: this.defaultPosition,\n      autoHideDelay,\n    });\n  }\n\n  /**\n   * Shows error state with optional retry\n   */\n  showError(message?: string, errorDetails?: string, onRetry?: () => void): void {\n    showErrorIndicator(this.video, {\n      message,\n      errorDetails,\n      onRetry,\n      position: this.defaultPosition,\n    });\n  }\n\n  /**\n   * Hides the indicator\n   */\n  hide(): void {\n    hideLoadingIndicator(this.video);\n  }\n\n  /**\n   * Removes the indicator from DOM\n   */\n  remove(): void {\n    removeLoadingIndicator(this.video);\n  }\n\n  /**\n   * Gets current status\n   */\n  getStatus(): IndicatorStatus {\n    return getIndicatorStatus(this.video);\n  }\n\n  /**\n   * Checks if visible\n   */\n  isVisible(): boolean {\n    return isIndicatorVisible(this.video);\n  }\n\n  /**\n   * Updates loading message\n   */\n  updateMessage(message: string): void {\n    updateLoadingMessage(this.video, message);\n  }\n}\n\n// ============================================\n// Exports\n// ============================================\n\nexport {\n  INDICATOR_ID,\n  INDICATOR_CLASS,\n};\n", "/**\n * Content Script Entrypoint\n *\n * Wires popup actions + background translation results to subtitle fetch/inject flow.\n *\n * Focus for Task ID: T-20251223-act-012-build-retranslate\n * - Listen for popup \"RETRANSLATE_CURRENT\"\n * - Trigger translation with force flag\n * - Handle cache hit / translation complete messages\n *\n * Updated for Task ID: T-20251223-act-013-build-loading-indicator\n * - Show loading indicator during translation\n * - Show success/error indicators on completion\n */\n\nimport { fetchSubtitles } from './subtitle-fetcher';\nimport { injectTrack } from './track-injector';\nimport { extractCourseInfo } from './subtitle-fetcher';\nimport { detectNextLecture } from './next-lecture-detector';\nimport { loadSettings, isEnabled } from '../storage/settings-manager';\nimport {\n  showLoadingIndicator,\n  showSuccessIndicator,\n  showErrorIndicator,\n  hideLoadingIndicator,\n} from './loading-indicator';\n\nconst LOG_PREFIX = '[UdemyCaptionPlus][Content]';\n\nfunction log(...args: unknown[]): void {\n  // eslint-disable-next-line no-console\n  console.log(LOG_PREFIX, ...args);\n}\n\nfunction generateTaskId(prefix: string): string {\n  return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n}\n\nlet activeTranslationTaskId: string | null = null;\nlet lastPreloadKey: string | null = null;\n\nasync function requestTranslation(options: { force: boolean; taskId?: string }): Promise<void> {\n  const settings = await loadSettings();\n  if (!isEnabled(settings)) {\n    log('Translation not enabled or not configured');\n    return;\n  }\n\n  const { videoDetection, vttContent } = await fetchSubtitles();\n  if (!videoDetection.found || !videoDetection.video) {\n    log('Video not found');\n    return;\n  }\n  if (!videoDetection.courseInfo) {\n    log('Course info not available');\n    return;\n  }\n  if (!vttContent) {\n    log('No VTT content fetched');\n    return;\n  }\n\n  const courseInfo = videoDetection.courseInfo;\n  const taskId = options.taskId ?? generateTaskId(options.force ? 'retranslate' : 'translate');\n\n  const courseId = courseInfo.courseId || courseInfo.courseSlug || 'unknown-course';\n  const lectureId = courseInfo.lectureId || 'unknown-lecture';\n\n  activeTranslationTaskId = taskId;\n\n  // Show loading indicator if enabled\n  if (settings.showLoadingIndicator) {\n    showLoadingIndicator(videoDetection.video, {\n      message: options.force ? '\u6B63\u5728\u91CD\u65B0\u7FFB\u8BD1\u2026' : '\u5B57\u5E55\u7FFB\u8BD1\u4E2D\u2026',\n    });\n  }\n\n  const message = {\n    type: 'TRANSLATE_SUBTITLE',\n    payload: {\n      taskId,\n      vttContent: vttContent.content,\n      originalHash: vttContent.hash,\n      courseId,\n      lectureId,\n      courseName: courseInfo.courseTitle || '',\n      sectionName: courseInfo.sectionTitle || '',\n      lectureName: courseInfo.lectureTitle || '',\n      provider: settings.provider,\n      model: settings.model,\n      force: options.force,\n    },\n  };\n\n  try {\n    await chrome.runtime.sendMessage(message);\n  } catch (error) {\n    log('Failed to send translation request:', error);\n    // Show error indicator\n    if (settings.showLoadingIndicator) {\n      showErrorIndicator(videoDetection.video, {\n        message: '\u8BF7\u6C42\u53D1\u9001\u5931\u8D25',\n        errorDetails: String(error),\n        onRetry: () => requestTranslation(options),\n      });\n    }\n  }\n}\n\nasync function requestPreloadNextLecture(): Promise<void> {\n  const settings = await loadSettings();\n  if (!isEnabled(settings) || !settings.preloadEnabled) return;\n\n  const courseInfo = extractCourseInfo();\n  if (!courseInfo) return;\n\n  const courseId = courseInfo.courseId || courseInfo.courseSlug || 'unknown-course';\n  const currentLectureId = courseInfo.lectureId;\n\n  const result = await detectNextLecture({\n    courseId,\n    courseSlug: courseInfo.courseSlug,\n    currentLectureId,\n  });\n\n  if (!result.nextLectureId) return;\n\n  const preloadKey = `${courseId}-${result.nextLectureId}`;\n  if (preloadKey === lastPreloadKey) return;\n  lastPreloadKey = preloadKey;\n\n  const message = {\n    type: 'PRELOAD_NEXT',\n    payload: {\n      courseId,\n      nextLectureId: result.nextLectureId,\n      nextLectureTitle: result.nextLectureTitle || '',\n      courseName: courseInfo.courseTitle || '',\n      sectionName: courseInfo.sectionTitle || '',\n    },\n  };\n\n  try {\n    await chrome.runtime.sendMessage(message);\n  } catch (error) {\n    log('Failed to send preload request:', error);\n  }\n}\n\nasync function cancelActiveTranslation(): Promise<void> {\n  if (!activeTranslationTaskId) return;\n  const taskId = activeTranslationTaskId;\n  activeTranslationTaskId = null;\n\n  // Hide loading indicator when cancelling\n  const video = document.querySelector('video');\n  if (video instanceof HTMLVideoElement) {\n    hideLoadingIndicator(video);\n  }\n\n  try {\n    await chrome.runtime.sendMessage({ type: 'CANCEL_TRANSLATION', payload: { taskId } });\n  } catch {\n    // ignore\n  }\n}\n\nfunction setupMessageListeners(): void {\n  if (typeof chrome === 'undefined' || !chrome.runtime?.onMessage) return;\n\n  chrome.runtime.onMessage.addListener((message: any, _sender, sendResponse): void | boolean => {\n    if (!message || typeof message !== 'object') return;\n\n    // Ignore popup-targeted broadcasts\n    if (message.meta?.target === 'popup') return;\n\n    if (message.type === 'RETRANSLATE_CURRENT') {\n      const taskId = message.payload?.taskId;\n      requestTranslation({ force: true, taskId })\n        .then(() => sendResponse?.({ ok: true }))\n        .catch((error) => sendResponse?.({ ok: false, error: String(error) }));\n      return true;\n    }\n\n    if (message.type === 'CACHE_HIT') {\n      if (message.payload?.taskId && message.payload.taskId === activeTranslationTaskId) {\n        activeTranslationTaskId = null;\n      }\n      const translatedVTT = message.payload?.translatedVTT;\n      if (typeof translatedVTT === 'string' && translatedVTT.trim().startsWith('WEBVTT')) {\n        const video = document.querySelector('video');\n        if (video instanceof HTMLVideoElement) {\n          injectTrack(video, translatedVTT, { activate: true });\n          // Show success indicator (cache hit)\n          loadSettings().then((settings) => {\n            if (settings.showLoadingIndicator) {\n              showSuccessIndicator(video, { message: '\u7F13\u5B58\u547D\u4E2D' });\n            }\n          });\n        }\n      }\n      return;\n    }\n\n    if (message.type === 'TRANSLATION_COMPLETE') {\n      if (message.payload?.taskId && message.payload.taskId === activeTranslationTaskId) {\n        activeTranslationTaskId = null;\n      }\n      const translatedVTT = message.payload?.translatedVTT;\n      const video = document.querySelector('video');\n      if (message.payload?.success === true && typeof translatedVTT === 'string') {\n        if (video instanceof HTMLVideoElement) {\n          injectTrack(video, translatedVTT, { activate: true });\n          // Show success indicator\n          loadSettings().then((settings) => {\n            if (settings.showLoadingIndicator) {\n              showSuccessIndicator(video, { message: '\u7FFB\u8BD1\u5B8C\u6210' });\n            }\n          });\n        }\n      } else {\n        const errorMsg = message.payload?.error || 'unknown error';\n        log('Translation failed:', errorMsg);\n        // Show error indicator with retry\n        if (video instanceof HTMLVideoElement) {\n          loadSettings().then((settings) => {\n            if (settings.showLoadingIndicator) {\n              showErrorIndicator(video, {\n                message: '\u7FFB\u8BD1\u5931\u8D25',\n                errorDetails: String(errorMsg),\n                onRetry: () => requestTranslation({ force: true }),\n              });\n            }\n          });\n        }\n      }\n      return;\n    }\n\n    return;\n  });\n}\n\nasync function autoTranslateIfEnabled(): Promise<void> {\n  try {\n    const settings = await loadSettings();\n    if (!isEnabled(settings) || !settings.autoTranslate) return;\n    await requestTranslation({ force: false });\n  } catch (error) {\n    log('Auto-translate init failed:', error);\n  }\n}\n\nfunction getLectureIdFromUrl(): string | null {\n  return window.location.pathname.match(/\\/learn\\/lecture\\/(\\d+)/)?.[1] ?? null;\n}\n\nfunction watchLectureNavigation(): void {\n  let lastLectureId = getLectureIdFromUrl();\n\n  setInterval(() => {\n    const currentLectureId = getLectureIdFromUrl();\n    if (!currentLectureId || currentLectureId === lastLectureId) return;\n    lastLectureId = currentLectureId;\n\n    lastPreloadKey = null;\n\n    cancelActiveTranslation()\n      .then(() => autoTranslateIfEnabled())\n      .then(() => requestPreloadNextLecture())\n      .catch((error) => log('Lecture navigation handler failed:', error));\n  }, 1000);\n}\n\nfunction init(): void {\n  setupMessageListeners();\n  watchLectureNavigation();\n  void autoTranslateIfEnabled();\n  void requestPreloadNextLecture();\n}\n\ninit();\n"],
  "mappings": "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",
  "names": ["LOG_PREFIX", "LOG_LEVELS", "currentLogLevel", "log", "log", "LOG_PREFIX", "LOG_LEVELS", "currentLogLevel", "log", "log", "log", "log", "LOG_PREFIX", "log", "LOG_PREFIX", "log"]
}
