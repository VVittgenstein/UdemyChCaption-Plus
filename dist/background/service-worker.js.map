{
  "version": 3,
  "sources": ["../../src/storage/settings-manager.ts", "../../src/storage/subtitle-cache.ts", "../../src/storage/session-cost.ts", "../../src/utils/hash.ts", "../../src/services/version-checker.ts", "../../src/utils/webvtt-parser.ts", "../../src/utils/webvtt-generator.ts", "../../src/utils/cost-estimator.ts", "../../src/services/openai-client.ts", "../../src/services/gemini-client.ts", "../../src/services/translator.ts", "../../src/services/preloader.ts", "../../src/background/service-worker.ts"],
  "sourcesContent": ["/**\n * Settings Manager for Udemy \u5B57\u5E55\u589E\u5F3A\n * Task ID: T-20251223-act-009-build-popup-settings\n *\n * Provides a unified interface for reading and writing user settings\n * using chrome.storage.sync. Can be used by popup, content script,\n * and service worker.\n */\n\nimport type { UserSettings } from '../types';\n\n// ============================================\n// Constants\n// ============================================\n\n/**\n * Default settings\n */\nexport const DEFAULT_SETTINGS: UserSettings = {\n  provider: 'openai',\n  apiKey: '',\n  model: 'gpt-5.1',\n  enabled: true,\n  autoTranslate: true,\n  preloadEnabled: true,\n  showCostEstimate: true,\n  showLoadingIndicator: true,\n};\n\n/**\n * Available models for each provider\n */\nexport const PROVIDER_MODELS: Record<string, { value: string; label: string; costPer1kTokens: number }[]> = {\n  openai: [\n    { value: 'gpt-5.2', label: 'GPT-5.2', costPer1kTokens: 0.01 },\n    { value: 'gpt-5.1', label: 'GPT-5.1', costPer1kTokens: 0.008 },\n    { value: 'gpt-5-pro', label: 'GPT-5 Pro', costPer1kTokens: 0.015 },\n    { value: 'gpt-5', label: 'GPT-5', costPer1kTokens: 0.006 },\n  ],\n  gemini: [\n    { value: 'gemini-3-pro-preview', label: 'Gemini 3 Pro Preview', costPer1kTokens: 0.005 },\n    { value: 'gemini-3-flash-preview', label: 'Gemini 3 Flash Preview', costPer1kTokens: 0.001 },\n    { value: 'gemini-2.5-pro', label: 'Gemini 2.5 Pro', costPer1kTokens: 0.003 },\n    { value: 'gemini-2.5-flash', label: 'Gemini 2.5 Flash', costPer1kTokens: 0.0005 },\n  ],\n};\n\n/**\n * Storage key for settings\n */\nconst STORAGE_KEY = 'udemy-caption-settings';\n\n// ============================================\n// Type Guards\n// ============================================\n\n/**\n * Check if running in Chrome extension context\n */\nfunction isChromeExtension(): boolean {\n  return typeof chrome !== 'undefined' && !!chrome.storage?.sync;\n}\n\n// ============================================\n// Storage Operations\n// ============================================\n\n/**\n * Load settings from storage\n * Uses chrome.storage.sync in extension context, localStorage as fallback\n */\nexport async function loadSettings(): Promise<UserSettings> {\n  return new Promise((resolve) => {\n    if (isChromeExtension()) {\n      chrome.storage.sync.get(DEFAULT_SETTINGS, (result) => {\n        resolve(result as UserSettings);\n      });\n    } else {\n      // Fallback for development/testing\n      const stored = localStorage.getItem(STORAGE_KEY);\n      if (stored) {\n        try {\n          resolve({ ...DEFAULT_SETTINGS, ...JSON.parse(stored) });\n        } catch {\n          resolve(DEFAULT_SETTINGS);\n        }\n      } else {\n        resolve(DEFAULT_SETTINGS);\n      }\n    }\n  });\n}\n\n/**\n * Save settings to storage\n * Uses chrome.storage.sync in extension context, localStorage as fallback\n */\nexport async function saveSettings(settings: Partial<UserSettings>): Promise<void> {\n  return new Promise((resolve, reject) => {\n    if (isChromeExtension()) {\n      chrome.storage.sync.set(settings, () => {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message));\n        } else {\n          resolve();\n        }\n      });\n    } else {\n      // Fallback for development/testing\n      try {\n        const current = localStorage.getItem(STORAGE_KEY);\n        const merged = { ...(current ? JSON.parse(current) : DEFAULT_SETTINGS), ...settings };\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(merged));\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    }\n  });\n}\n\n/**\n * Clear all settings and reset to defaults\n */\nexport async function resetSettings(): Promise<void> {\n  return saveSettings(DEFAULT_SETTINGS);\n}\n\n/**\n * Get a single setting value\n */\nexport async function getSetting<K extends keyof UserSettings>(key: K): Promise<UserSettings[K]> {\n  const settings = await loadSettings();\n  return settings[key];\n}\n\n/**\n * Set a single setting value\n */\nexport async function setSetting<K extends keyof UserSettings>(\n  key: K,\n  value: UserSettings[K]\n): Promise<void> {\n  return saveSettings({ [key]: value });\n}\n\n// ============================================\n// Settings Change Listener\n// ============================================\n\ntype SettingsChangeCallback = (newSettings: UserSettings, oldSettings: UserSettings) => void;\n\nconst changeListeners: Set<SettingsChangeCallback> = new Set();\n\n/**\n * Subscribe to settings changes\n * Returns an unsubscribe function\n */\nexport function onSettingsChange(callback: SettingsChangeCallback): () => void {\n  changeListeners.add(callback);\n\n  // Set up chrome.storage listener if in extension context\n  if (isChromeExtension() && changeListeners.size === 1) {\n    chrome.storage.onChanged.addListener(handleStorageChange);\n  }\n\n  return () => {\n    changeListeners.delete(callback);\n    if (isChromeExtension() && changeListeners.size === 0) {\n      chrome.storage.onChanged.removeListener(handleStorageChange);\n    }\n  };\n}\n\n/**\n * Handle chrome.storage change events\n */\nfunction handleStorageChange(\n  changes: { [key: string]: chrome.storage.StorageChange },\n  areaName: string\n): void {\n  if (areaName !== 'sync') return;\n\n  // Build old and new settings objects\n  const oldSettings: Partial<UserSettings> = {};\n  const newSettings: Partial<UserSettings> = {};\n\n  for (const key of Object.keys(changes) as Array<keyof UserSettings>) {\n    if (key in DEFAULT_SETTINGS) {\n      oldSettings[key] = changes[key].oldValue;\n      newSettings[key] = changes[key].newValue;\n    }\n  }\n\n  // Notify listeners\n  loadSettings().then((currentSettings) => {\n    const previousSettings = { ...currentSettings };\n    for (const key of Object.keys(oldSettings) as Array<keyof UserSettings>) {\n      if (oldSettings[key] !== undefined) {\n        (previousSettings as Record<string, unknown>)[key] = oldSettings[key];\n      }\n    }\n\n    for (const listener of changeListeners) {\n      try {\n        listener(currentSettings, previousSettings);\n      } catch (error) {\n        console.error('[SettingsManager] Error in change listener:', error);\n      }\n    }\n  });\n}\n\n// ============================================\n// Utility Functions\n// ============================================\n\n/**\n * Check if settings are valid for translation\n */\nexport function isConfigured(settings: UserSettings): boolean {\n  return !!settings.apiKey && !!settings.model && !!settings.provider;\n}\n\n/**\n * Check if translation is enabled\n */\nexport function isEnabled(settings: UserSettings): boolean {\n  return settings.enabled && isConfigured(settings);\n}\n\n/**\n * Get model info for the current settings\n */\nexport function getModelInfo(settings: UserSettings): {\n  label: string;\n  costPer1kTokens: number;\n} | null {\n  const models = PROVIDER_MODELS[settings.provider];\n  if (!models) return null;\n\n  const model = models.find((m) => m.value === settings.model);\n  return model ? { label: model.label, costPer1kTokens: model.costPer1kTokens } : null;\n}\n\n/**\n * Estimate cost for a given number of tokens\n */\nexport function estimateCost(settings: UserSettings, tokenCount: number): number {\n  const modelInfo = getModelInfo(settings);\n  if (!modelInfo) return 0;\n\n  return (tokenCount / 1000) * modelInfo.costPer1kTokens;\n}\n\n// ============================================\n// Export SettingsManager class for OOP usage\n// ============================================\n\n/**\n * Settings Manager class for object-oriented usage\n */\nexport class SettingsManager {\n  private cachedSettings: UserSettings | null = null;\n  private unsubscribe: (() => void) | null = null;\n\n  /**\n   * Initialize the settings manager\n   */\n  async init(): Promise<UserSettings> {\n    this.cachedSettings = await loadSettings();\n\n    // Subscribe to changes to keep cache updated\n    this.unsubscribe = onSettingsChange((newSettings) => {\n      this.cachedSettings = newSettings;\n    });\n\n    return this.cachedSettings;\n  }\n\n  /**\n   * Get current settings (from cache if available)\n   */\n  async getSettings(): Promise<UserSettings> {\n    if (this.cachedSettings) {\n      return this.cachedSettings;\n    }\n    return loadSettings();\n  }\n\n  /**\n   * Update settings\n   */\n  async updateSettings(settings: Partial<UserSettings>): Promise<void> {\n    await saveSettings(settings);\n    if (this.cachedSettings) {\n      this.cachedSettings = { ...this.cachedSettings, ...settings };\n    }\n  }\n\n  /**\n   * Check if translation is enabled\n   */\n  isEnabled(): boolean {\n    if (!this.cachedSettings) return false;\n    return isEnabled(this.cachedSettings);\n  }\n\n  /**\n   * Check if settings are configured\n   */\n  isConfigured(): boolean {\n    if (!this.cachedSettings) return false;\n    return isConfigured(this.cachedSettings);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = null;\n    }\n    this.cachedSettings = null;\n  }\n}\n\n// Export singleton instance\nexport const settingsManager = new SettingsManager();\n", "/**\n * Subtitle Cache Module - IndexedDB Storage for Translated Subtitles\n * Task ID: T-20251223-act-010-build-local-cache\n *\n * Provides persistent storage for translated subtitles using IndexedDB.\n * Features:\n * - Cache by course/lecture ID with original subtitle hash validation\n * - LRU eviction when cache size exceeds limit\n * - Query, write, delete operations\n * - Statistics and maintenance utilities\n */\n\nimport type { SubtitleCacheEntry } from '../types';\n\n// ============================================\n// Constants\n// ============================================\n\n/** Database name */\nconst DB_NAME = 'UdemyCaptionCache';\n\n/** Database version - increment when schema changes */\nconst DB_VERSION = 1;\n\n/** Object store name for subtitle cache */\nconst STORE_NAME = 'subtitles';\n\n/** Default maximum cache entries (LRU eviction threshold) */\nconst DEFAULT_MAX_ENTRIES = 500;\n\n/** Default maximum cache size in bytes (100MB) */\nconst DEFAULT_MAX_SIZE_BYTES = 100 * 1024 * 1024;\n\n// ============================================\n// Types\n// ============================================\n\n/**\n * Options for cache operations\n */\nexport interface CacheOptions {\n  /** Maximum number of entries to keep (default: 500) */\n  maxEntries?: number;\n  /** Maximum cache size in bytes (default: 100MB) */\n  maxSizeBytes?: number;\n  /** Enable auto-eviction when limits exceeded (default: true) */\n  autoEvict?: boolean;\n}\n\n/**\n * Cache statistics\n */\nexport interface CacheStats {\n  /** Total number of cached entries */\n  totalEntries: number;\n  /** Approximate total size in bytes */\n  totalSizeBytes: number;\n  /** Oldest entry timestamp */\n  oldestEntry: number | null;\n  /** Newest entry timestamp */\n  newestEntry: number | null;\n  /** Total tokens used across all cached translations */\n  totalTokensUsed: number;\n  /** Total estimated cost across all cached translations */\n  totalEstimatedCost: number;\n}\n\n/**\n * Cache lookup result\n */\nexport interface CacheLookupResult {\n  /** Whether cache hit occurred */\n  hit: boolean;\n  /** Cached entry if found */\n  entry?: SubtitleCacheEntry;\n  /** Whether hash matched (relevant only if entry found) */\n  hashMatch?: boolean;\n}\n\n/**\n * Input for creating a cache entry\n */\nexport interface CacheEntryInput {\n  courseId: string;\n  lectureId: string;\n  courseName: string;\n  lectureName: string;\n  originalHash: string;\n  translatedVTT: string;\n  provider: string;\n  model: string;\n  tokensUsed: number;\n  estimatedCost: number;\n}\n\n// ============================================\n// IndexedDB Helpers\n// ============================================\n\n/**\n * Open the IndexedDB database\n */\nfunction openDatabase(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => {\n      reject(new Error(`Failed to open database: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n\n      // Create object store if it doesn't exist\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });\n\n        // Indexes for efficient queries\n        store.createIndex('courseId', 'courseId', { unique: false });\n        store.createIndex('lectureId', 'lectureId', { unique: false });\n        store.createIndex('updatedAt', 'updatedAt', { unique: false });\n        store.createIndex('createdAt', 'createdAt', { unique: false });\n        store.createIndex('provider', 'provider', { unique: false });\n        store.createIndex('model', 'model', { unique: false });\n      }\n    };\n  });\n}\n\n/**\n * Generate cache key from course and lecture IDs\n */\nexport function generateCacheKey(courseId: string, lectureId: string): string {\n  return `${courseId}-${lectureId}`;\n}\n\n/**\n * Estimate the size of a cache entry in bytes\n */\nfunction estimateEntrySize(entry: SubtitleCacheEntry): number {\n  // Rough estimation: JSON stringify length * 2 (for UTF-16)\n  return JSON.stringify(entry).length * 2;\n}\n\n// ============================================\n// Core Cache Operations\n// ============================================\n\n/**\n * Get a cached subtitle entry\n * @param courseId Course ID\n * @param lectureId Lecture ID\n * @param originalHash Optional hash to verify content hasn't changed\n */\nexport async function getCache(\n  courseId: string,\n  lectureId: string,\n  originalHash?: string\n): Promise<CacheLookupResult> {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const key = generateCacheKey(courseId, lectureId);\n    const request = store.get(key);\n\n    request.onerror = () => {\n      db.close();\n      reject(new Error(`Failed to get cache entry: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      db.close();\n      const entry = request.result as SubtitleCacheEntry | undefined;\n\n      if (!entry) {\n        resolve({ hit: false });\n        return;\n      }\n\n      // If hash provided, check if it matches\n      if (originalHash !== undefined) {\n        const hashMatch = entry.originalHash === originalHash;\n        resolve({ hit: true, entry, hashMatch });\n      } else {\n        resolve({ hit: true, entry });\n      }\n    };\n  });\n}\n\n/**\n * Store a translated subtitle in cache\n * Updates existing entry if present, creates new otherwise\n */\nexport async function setCache(\n  input: CacheEntryInput,\n  options: CacheOptions = {}\n): Promise<SubtitleCacheEntry> {\n  const { autoEvict = true } = options;\n\n  const db = await openDatabase();\n  const now = Date.now();\n  const key = generateCacheKey(input.courseId, input.lectureId);\n\n  // Check for existing entry to preserve createdAt\n  const existingEntry = await new Promise<SubtitleCacheEntry | undefined>((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.get(key);\n\n    request.onerror = () => reject(new Error('Failed to check existing entry'));\n    request.onsuccess = () => resolve(request.result);\n  });\n\n  const entry: SubtitleCacheEntry = {\n    id: key,\n    courseId: input.courseId,\n    lectureId: input.lectureId,\n    courseName: input.courseName,\n    lectureName: input.lectureName,\n    originalHash: input.originalHash,\n    translatedVTT: input.translatedVTT,\n    provider: input.provider,\n    model: input.model,\n    tokensUsed: input.tokensUsed,\n    estimatedCost: input.estimatedCost,\n    createdAt: existingEntry?.createdAt ?? now,\n    updatedAt: now,\n  };\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.put(entry);\n\n    request.onerror = () => {\n      db.close();\n      reject(new Error(`Failed to set cache entry: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      db.close();\n\n      // Trigger eviction check in background if enabled\n      if (autoEvict) {\n        evictIfNeeded(options).catch(console.error);\n      }\n\n      resolve(entry);\n    };\n  });\n}\n\n/**\n * Delete a cached subtitle entry\n */\nexport async function deleteCache(courseId: string, lectureId: string): Promise<boolean> {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const key = generateCacheKey(courseId, lectureId);\n    const request = store.delete(key);\n\n    request.onerror = () => {\n      db.close();\n      reject(new Error(`Failed to delete cache entry: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      db.close();\n      resolve(true);\n    };\n  });\n}\n\n/**\n * Delete all cached subtitles for a course\n */\nexport async function deleteCourseCache(courseId: string): Promise<number> {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const index = store.index('courseId');\n    const request = index.openCursor(IDBKeyRange.only(courseId));\n\n    let deletedCount = 0;\n\n    request.onerror = () => {\n      db.close();\n      reject(new Error(`Failed to delete course cache: ${request.error?.message}`));\n    };\n\n    request.onsuccess = (event) => {\n      const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;\n      if (cursor) {\n        cursor.delete();\n        deletedCount++;\n        cursor.continue();\n      } else {\n        db.close();\n        resolve(deletedCount);\n      }\n    };\n  });\n}\n\n/**\n * Clear all cached subtitles\n */\nexport async function clearAllCache(): Promise<void> {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.clear();\n\n    request.onerror = () => {\n      db.close();\n      reject(new Error(`Failed to clear cache: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      db.close();\n      resolve();\n    };\n  });\n}\n\n// ============================================\n// Query Operations\n// ============================================\n\n/**\n * Get all cached entries for a course\n */\nexport async function getCourseEntries(courseId: string): Promise<SubtitleCacheEntry[]> {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const index = store.index('courseId');\n    const request = index.getAll(IDBKeyRange.only(courseId));\n\n    request.onerror = () => {\n      db.close();\n      reject(new Error(`Failed to get course entries: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      db.close();\n      resolve(request.result);\n    };\n  });\n}\n\n/**\n * Get all cached entries\n */\nexport async function getAllEntries(): Promise<SubtitleCacheEntry[]> {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.getAll();\n\n    request.onerror = () => {\n      db.close();\n      reject(new Error(`Failed to get all entries: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      db.close();\n      resolve(request.result);\n    };\n  });\n}\n\n/**\n * Get total number of cached entries\n */\nexport async function getCacheCount(): Promise<number> {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.count();\n\n    request.onerror = () => {\n      db.close();\n      reject(new Error(`Failed to get cache count: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      db.close();\n      resolve(request.result);\n    };\n  });\n}\n\n/**\n * Get cache statistics\n */\nexport async function getCacheStats(): Promise<CacheStats> {\n  const entries = await getAllEntries();\n\n  if (entries.length === 0) {\n    return {\n      totalEntries: 0,\n      totalSizeBytes: 0,\n      oldestEntry: null,\n      newestEntry: null,\n      totalTokensUsed: 0,\n      totalEstimatedCost: 0,\n    };\n  }\n\n  let totalSizeBytes = 0;\n  let oldestEntry = Infinity;\n  let newestEntry = 0;\n  let totalTokensUsed = 0;\n  let totalEstimatedCost = 0;\n\n  for (const entry of entries) {\n    totalSizeBytes += estimateEntrySize(entry);\n    oldestEntry = Math.min(oldestEntry, entry.createdAt);\n    newestEntry = Math.max(newestEntry, entry.updatedAt);\n    totalTokensUsed += entry.tokensUsed;\n    totalEstimatedCost += entry.estimatedCost;\n  }\n\n  return {\n    totalEntries: entries.length,\n    totalSizeBytes,\n    oldestEntry: oldestEntry === Infinity ? null : oldestEntry,\n    newestEntry: newestEntry === 0 ? null : newestEntry,\n    totalTokensUsed,\n    totalEstimatedCost,\n  };\n}\n\n// ============================================\n// LRU Eviction\n// ============================================\n\n/**\n * Check if eviction is needed and perform LRU eviction\n */\nexport async function evictIfNeeded(options: CacheOptions = {}): Promise<number> {\n  const { maxEntries = DEFAULT_MAX_ENTRIES, maxSizeBytes = DEFAULT_MAX_SIZE_BYTES } = options;\n\n  const stats = await getCacheStats();\n\n  // Check if eviction is needed\n  const needsEntryEviction = stats.totalEntries > maxEntries;\n  const needsSizeEviction = stats.totalSizeBytes > maxSizeBytes;\n\n  if (!needsEntryEviction && !needsSizeEviction) {\n    return 0;\n  }\n\n  // Get entries sorted by updatedAt (LRU order)\n  const entries = await getAllEntries();\n  entries.sort((a, b) => a.updatedAt - b.updatedAt);\n\n  let evictedCount = 0;\n  let currentSize = stats.totalSizeBytes;\n  let currentCount = stats.totalEntries;\n\n  for (const entry of entries) {\n    // Stop if both conditions are satisfied\n    const countOk = currentCount <= maxEntries;\n    const sizeOk = currentSize <= maxSizeBytes;\n    if (countOk && sizeOk) break;\n\n    // Evict this entry\n    await deleteCache(entry.courseId, entry.lectureId);\n    evictedCount++;\n    currentCount--;\n    currentSize -= estimateEntrySize(entry);\n  }\n\n  return evictedCount;\n}\n\n/**\n * Manually trigger cache cleanup with custom limits\n */\nexport async function cleanupCache(options: CacheOptions = {}): Promise<{\n  evictedCount: number;\n  remainingEntries: number;\n  remainingSizeBytes: number;\n}> {\n  const evictedCount = await evictIfNeeded(options);\n  const stats = await getCacheStats();\n\n  return {\n    evictedCount,\n    remainingEntries: stats.totalEntries,\n    remainingSizeBytes: stats.totalSizeBytes,\n  };\n}\n\n// ============================================\n// Touch (Update Access Time)\n// ============================================\n\n/**\n * Update the access time of a cache entry (for LRU tracking)\n * Call this when a cached entry is used\n */\nexport async function touchCache(courseId: string, lectureId: string): Promise<boolean> {\n  const db = await openDatabase();\n  const key = generateCacheKey(courseId, lectureId);\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const getRequest = store.get(key);\n\n    getRequest.onerror = () => {\n      db.close();\n      reject(new Error(`Failed to touch cache entry: ${getRequest.error?.message}`));\n    };\n\n    getRequest.onsuccess = () => {\n      const entry = getRequest.result as SubtitleCacheEntry | undefined;\n      if (!entry) {\n        db.close();\n        resolve(false);\n        return;\n      }\n\n      // Update the updatedAt timestamp\n      entry.updatedAt = Date.now();\n      const putRequest = store.put(entry);\n\n      putRequest.onerror = () => {\n        db.close();\n        reject(new Error(`Failed to update cache entry: ${putRequest.error?.message}`));\n      };\n\n      putRequest.onsuccess = () => {\n        db.close();\n        resolve(true);\n      };\n    };\n  });\n}\n\n// ============================================\n// SubtitleCache Class (OOP Interface)\n// ============================================\n\n/**\n * Object-oriented interface for subtitle cache operations\n */\nexport class SubtitleCache {\n  private options: CacheOptions;\n\n  constructor(options: CacheOptions = {}) {\n    this.options = {\n      maxEntries: options.maxEntries ?? DEFAULT_MAX_ENTRIES,\n      maxSizeBytes: options.maxSizeBytes ?? DEFAULT_MAX_SIZE_BYTES,\n      autoEvict: options.autoEvict ?? true,\n    };\n  }\n\n  /**\n   * Get a cached subtitle, optionally validating hash\n   */\n  async get(\n    courseId: string,\n    lectureId: string,\n    originalHash?: string\n  ): Promise<CacheLookupResult> {\n    const result = await getCache(courseId, lectureId, originalHash);\n\n    // Touch the entry if found to update LRU order\n    if (result.hit) {\n      await touchCache(courseId, lectureId).catch(() => {});\n    }\n\n    return result;\n  }\n\n  /**\n   * Store a translated subtitle\n   */\n  async set(input: CacheEntryInput): Promise<SubtitleCacheEntry> {\n    return setCache(input, this.options);\n  }\n\n  /**\n   * Delete a cached subtitle\n   */\n  async delete(courseId: string, lectureId: string): Promise<boolean> {\n    return deleteCache(courseId, lectureId);\n  }\n\n  /**\n   * Delete all cached subtitles for a course\n   */\n  async deleteCourse(courseId: string): Promise<number> {\n    return deleteCourseCache(courseId);\n  }\n\n  /**\n   * Clear all cached subtitles\n   */\n  async clear(): Promise<void> {\n    return clearAllCache();\n  }\n\n  /**\n   * Get all cached entries for a course\n   */\n  async getCourseEntries(courseId: string): Promise<SubtitleCacheEntry[]> {\n    return getCourseEntries(courseId);\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getStats(): Promise<CacheStats> {\n    return getCacheStats();\n  }\n\n  /**\n   * Get total number of cached entries\n   */\n  async getCount(): Promise<number> {\n    return getCacheCount();\n  }\n\n  /**\n   * Check if a subtitle is cached\n   */\n  async has(courseId: string, lectureId: string): Promise<boolean> {\n    const result = await getCache(courseId, lectureId);\n    return result.hit;\n  }\n\n  /**\n   * Check if a subtitle is cached with matching hash\n   */\n  async hasValid(courseId: string, lectureId: string, originalHash: string): Promise<boolean> {\n    const result = await getCache(courseId, lectureId, originalHash);\n    return result.hit && result.hashMatch === true;\n  }\n\n  /**\n   * Manually trigger cache cleanup\n   */\n  async cleanup(): Promise<{\n    evictedCount: number;\n    remainingEntries: number;\n    remainingSizeBytes: number;\n  }> {\n    return cleanupCache(this.options);\n  }\n\n  /**\n   * Update cache options\n   */\n  setOptions(options: Partial<CacheOptions>): void {\n    this.options = { ...this.options, ...options };\n  }\n}\n\n// ============================================\n// Export Singleton Instance\n// ============================================\n\n/** Default subtitle cache instance */\nexport const subtitleCache = new SubtitleCache();\n\n// ============================================\n// Database Management\n// ============================================\n\n/**\n * Check if IndexedDB is available\n */\nexport function isIndexedDBAvailable(): boolean {\n  return typeof indexedDB !== 'undefined';\n}\n\n/**\n * Delete the entire database (for troubleshooting)\n */\nexport async function deleteDatabase(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.deleteDatabase(DB_NAME);\n\n    request.onerror = () => {\n      reject(new Error(`Failed to delete database: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      resolve();\n    };\n\n    request.onblocked = () => {\n      reject(new Error('Database deletion blocked - close all connections first'));\n    };\n  });\n}\n", "/**\n * Session Cost Tracking\n *\n * Task ID: T-20251223-act-016-build-cost-estimate\n *\n * Tracks token usage and estimated USD cost for the current browser session.\n * Uses chrome.storage.session when available (MV3), with an in-memory fallback.\n */\n\nexport interface SessionCostTotals {\n  totalTokens: number;\n  totalCostUsd: number;\n  updatedAt: number;\n}\n\nexport interface TranslationEstimateSnapshot {\n  taskId: string;\n  provider: 'openai' | 'gemini';\n  model: string;\n  cueCount: number;\n  estimatedTotalTokens: number;\n  estimatedCostUsd: number;\n  createdAt: number;\n}\n\nexport interface TranslationActualSnapshot {\n  taskId: string;\n  provider: 'openai' | 'gemini';\n  model: string;\n  tokensUsed: number;\n  costUsd: number;\n  createdAt: number;\n}\n\nexport interface SessionCostState {\n  totals: SessionCostTotals;\n  lastEstimate?: TranslationEstimateSnapshot;\n  lastActual?: TranslationActualSnapshot;\n}\n\nconst STORAGE_KEY = 'udemy-caption-plus:session-cost';\n\nconst DEFAULT_STATE: SessionCostState = {\n  totals: {\n    totalTokens: 0,\n    totalCostUsd: 0,\n    updatedAt: 0,\n  },\n};\n\nlet memoryState: SessionCostState | null = null;\n\nfunction hasSessionStorage(): boolean {\n  return typeof chrome !== 'undefined' && !!chrome.storage?.session;\n}\n\nfunction loadFromMemory(): SessionCostState {\n  if (!memoryState) memoryState = structuredClone(DEFAULT_STATE);\n  return memoryState;\n}\n\nfunction saveToMemory(state: SessionCostState): void {\n  memoryState = state;\n}\n\nexport async function loadSessionCostState(): Promise<SessionCostState> {\n  if (!hasSessionStorage()) {\n    return loadFromMemory();\n  }\n\n  return new Promise((resolve) => {\n    chrome.storage.session.get({ [STORAGE_KEY]: DEFAULT_STATE }, (result) => {\n      resolve((result as Record<string, SessionCostState>)[STORAGE_KEY] ?? structuredClone(DEFAULT_STATE));\n    });\n  });\n}\n\nexport async function saveSessionCostState(state: SessionCostState): Promise<void> {\n  if (!hasSessionStorage()) {\n    saveToMemory(state);\n    return;\n  }\n\n  return new Promise((resolve, reject) => {\n    chrome.storage.session.set({ [STORAGE_KEY]: state }, () => {\n      if (chrome.runtime.lastError) {\n        reject(new Error(chrome.runtime.lastError.message));\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexport async function updateSessionCostState(patch: Partial<SessionCostState>): Promise<SessionCostState> {\n  const current = await loadSessionCostState();\n  const next: SessionCostState = {\n    ...current,\n    ...patch,\n    totals: {\n      ...current.totals,\n      ...(patch.totals || {}),\n    },\n  };\n\n  await saveSessionCostState(next);\n  return next;\n}\n\nexport async function addSessionCost(deltaTokens: number, deltaCostUsd: number): Promise<SessionCostState> {\n  const current = await loadSessionCostState();\n  const now = Date.now();\n\n  const next: SessionCostState = {\n    ...current,\n    totals: {\n      totalTokens: current.totals.totalTokens + deltaTokens,\n      totalCostUsd: current.totals.totalCostUsd + deltaCostUsd,\n      updatedAt: now,\n    },\n  };\n\n  await saveSessionCostState(next);\n  return next;\n}\n\n", "/**\n * Hash Utilities\n *\n * Shared hashing helpers for subtitle versioning and cache validation.\n */\n\n/**\n * Calculate SHA-256 hash of content (hex string).\n * Falls back to a simple non-cryptographic hash when crypto.subtle is unavailable.\n */\nexport async function calculateHash(content: string): Promise<string> {\n  try {\n    if (typeof crypto === 'undefined' || !crypto.subtle?.digest) {\n      throw new Error('crypto.subtle not available');\n    }\n\n    const encoder = new TextEncoder();\n    const data = encoder.encode(content);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n  } catch {\n    return simpleHash(content);\n  }\n}\n\n/**\n * Simple hash fallback (32-bit, hex string).\n * Not cryptographically secure; only used when SHA-256 is unavailable.\n */\nexport function simpleHash(str: string): string {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return Math.abs(hash).toString(16).padStart(8, '0');\n}\n\n", "/**\n * Subtitle Version Checker\n *\n * Task ID: T-20251223-act-012-build-retranslate\n *\n * Responsibilities:\n * - Compute/accept original subtitle hash\n * - Compare with cached entry hash\n * - Decide whether to retranslate (subtitle updated or user forces refresh)\n */\n\nimport type { SubtitleCacheEntry } from '../types';\nimport { subtitleCache } from '../storage/subtitle-cache';\nimport { calculateHash } from '../utils/hash';\n\nexport type VersionDecision = 'use_cache' | 'retranslate';\n\nexport type VersionDecisionReason =\n  | 'cache_valid'\n  | 'cache_miss'\n  | 'hash_changed'\n  | 'force';\n\nexport interface VersionCheckParams {\n  courseId: string;\n  lectureId: string;\n  /**\n   * Hash of the original VTT content.\n   * If not provided, `originalVtt` must be provided so we can compute it.\n   */\n  originalHash?: string;\n  /**\n   * Original VTT content used to compute hash when `originalHash` is not provided.\n   */\n  originalVtt?: string;\n  /**\n   * Force retranslation even if cache hash matches.\n   */\n  force?: boolean;\n}\n\nexport interface VersionCheckResult {\n  decision: VersionDecision;\n  reason: VersionDecisionReason;\n  originalHash: string;\n  cacheHit: boolean;\n  hashMatch?: boolean;\n  cachedEntry?: SubtitleCacheEntry;\n}\n\nasync function resolveOriginalHash(params: VersionCheckParams): Promise<string> {\n  if (params.originalHash) return params.originalHash;\n  if (params.originalVtt !== undefined) return calculateHash(params.originalVtt);\n  throw new Error('Either originalHash or originalVtt must be provided');\n}\n\n/**\n * Check whether the cached translation is still valid for the current original subtitle version.\n */\nexport async function checkSubtitleVersion(\n  params: VersionCheckParams\n) : Promise<VersionCheckResult> {\n  const originalHash = await resolveOriginalHash(params);\n  const { courseId, lectureId, force = false } = params;\n\n  const cacheResult = await subtitleCache.get(courseId, lectureId, originalHash);\n\n  if (force) {\n    return {\n      decision: 'retranslate',\n      reason: 'force',\n      originalHash,\n      cacheHit: cacheResult.hit,\n      hashMatch: cacheResult.hashMatch,\n      cachedEntry: cacheResult.entry,\n    };\n  }\n\n  if (!cacheResult.hit) {\n    return {\n      decision: 'retranslate',\n      reason: 'cache_miss',\n      originalHash,\n      cacheHit: false,\n    };\n  }\n\n  if (cacheResult.hashMatch === false) {\n    return {\n      decision: 'retranslate',\n      reason: 'hash_changed',\n      originalHash,\n      cacheHit: true,\n      hashMatch: false,\n      cachedEntry: cacheResult.entry,\n    };\n  }\n\n  return {\n    decision: 'use_cache',\n    reason: 'cache_valid',\n    originalHash,\n    cacheHit: true,\n    hashMatch: true,\n    cachedEntry: cacheResult.entry,\n  };\n}\n\n", "/**\n * WebVTT Parser Module\n *\n * Parses WebVTT (Web Video Text Tracks) files into structured data.\n * Supports standard WebVTT format including cue IDs, timestamps, text content,\n * style blocks, regions, and notes.\n *\n * Task ID: T-20251223-act-006-build-webvtt-parser\n *\n * Acceptance Criteria:\n * - [x] \u89E3\u6790\u5668\u53EF\u6B63\u786E\u89E3\u6790\u6807\u51C6 WebVTT \u6587\u4EF6\uFF08\u542B cue ID\u3001\u65F6\u95F4\u6233\u3001\u6587\u672C\uFF09\n * - [x] \u8FB9\u754C\u60C5\u51B5\u5904\u7406\uFF08\u7A7A\u6587\u4EF6\u3001\u683C\u5F0F\u9519\u8BEF\u7B49\uFF09\n *\n * @see https://www.w3.org/TR/webvtt1/\n */\n\nimport type {\n  VTTTimestamp,\n  VTTCue,\n  VTTFile,\n  VTTRegion,\n  VTTParseResult,\n} from '../types';\n\n// ============================================\n// Constants\n// ============================================\n\n/** Logger prefix */\nconst LOG_PREFIX = '[WebVTT Parser]';\n\n/** WebVTT file signature */\nconst WEBVTT_SIGNATURE = 'WEBVTT';\n\n/** Timestamp arrow separator */\nconst TIMESTAMP_ARROW = '-->';\n\n/**\n * Regex patterns for parsing\n */\nconst PATTERNS = {\n  /**\n   * Timestamp pattern: HH:MM:SS.mmm or MM:SS.mmm\n   * Groups: hours (optional), minutes, seconds, milliseconds\n   */\n  timestamp: /^(?:(\\d{1,2}):)?(\\d{2}):(\\d{2})\\.(\\d{3})$/,\n\n  /**\n   * Cue timing line pattern: START --> END [settings]\n   * Groups: startTime, endTime, settings (optional)\n   */\n  cueTiming: /^([\\d:.]+)\\s*-->\\s*([\\d:.]+)(?:\\s+(.+))?$/,\n\n  /**\n   * Style block start\n   */\n  styleStart: /^STYLE\\s*$/,\n\n  /**\n   * Region block start\n   */\n  regionStart: /^REGION\\s*$/,\n\n  /**\n   * Note block start\n   */\n  noteStart: /^NOTE\\b/,\n\n  /**\n   * BOM character\n   */\n  bom: /^\\uFEFF/,\n};\n\n// ============================================\n// Logger\n// ============================================\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nlet currentLogLevel: LogLevel = 'warn';\n\nfunction log(level: LogLevel, ...args: unknown[]): void {\n  if (LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel]) {\n    const method = level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log';\n    console[method](LOG_PREFIX, `[${level.toUpperCase()}]`, ...args);\n  }\n}\n\n/**\n * Set the logging level for the parser\n */\nexport function setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n// ============================================\n// Timestamp Parsing\n// ============================================\n\n/**\n * Parse a WebVTT timestamp string into a VTTTimestamp object\n *\n * @param timestamp - Timestamp string in format HH:MM:SS.mmm or MM:SS.mmm\n * @returns Parsed timestamp or null if invalid\n */\nexport function parseTimestamp(timestamp: string): VTTTimestamp | null {\n  const trimmed = timestamp.trim();\n  const match = trimmed.match(PATTERNS.timestamp);\n\n  if (!match) {\n    log('debug', `Invalid timestamp format: \"${timestamp}\"`);\n    return null;\n  }\n\n  const [, hoursStr, minutesStr, secondsStr, msStr] = match;\n\n  const hours = hoursStr ? parseInt(hoursStr, 10) : 0;\n  const minutes = parseInt(minutesStr, 10);\n  const seconds = parseInt(secondsStr, 10);\n  const milliseconds = parseInt(msStr, 10);\n\n  // Validate ranges\n  if (minutes > 59 || seconds > 59 || milliseconds > 999) {\n    log('debug', `Timestamp values out of range: \"${timestamp}\"`);\n    return null;\n  }\n\n  return { hours, minutes, seconds, milliseconds };\n}\n\n/**\n * Convert a VTTTimestamp to total milliseconds\n */\nexport function timestampToMs(ts: VTTTimestamp): number {\n  return (\n    ts.hours * 3600000 +\n    ts.minutes * 60000 +\n    ts.seconds * 1000 +\n    ts.milliseconds\n  );\n}\n\n/**\n * Convert milliseconds to a VTTTimestamp\n */\nexport function msToTimestamp(ms: number): VTTTimestamp {\n  const hours = Math.floor(ms / 3600000);\n  ms %= 3600000;\n  const minutes = Math.floor(ms / 60000);\n  ms %= 60000;\n  const seconds = Math.floor(ms / 1000);\n  const milliseconds = ms % 1000;\n\n  return { hours, minutes, seconds, milliseconds };\n}\n\n/**\n * Compare two timestamps\n * @returns negative if a < b, positive if a > b, 0 if equal\n */\nexport function compareTimestamps(a: VTTTimestamp, b: VTTTimestamp): number {\n  return timestampToMs(a) - timestampToMs(b);\n}\n\n// ============================================\n// Main Parser\n// ============================================\n\n/**\n * Parse a WebVTT file string into structured data\n *\n * @param vttString - Raw WebVTT file content\n * @returns Parse result containing the parsed file or error\n */\nexport function parseVTT(vttString: string): VTTParseResult {\n  const warnings: string[] = [];\n\n  // Handle empty input\n  if (!vttString || typeof vttString !== 'string') {\n    return {\n      success: false,\n      error: 'Empty or invalid input',\n    };\n  }\n\n  // Strip BOM if present\n  let content = vttString.replace(PATTERNS.bom, '');\n\n  // Normalize line endings to \\n\n  content = content.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n  // Split into lines\n  const lines = content.split('\\n');\n\n  // Check for WEBVTT signature\n  const firstLine = lines[0]?.trim() || '';\n  if (!firstLine.startsWith(WEBVTT_SIGNATURE)) {\n    return {\n      success: false,\n      error: `Invalid WebVTT file: missing WEBVTT signature (found: \"${firstLine.substring(0, 20)}\")`,\n    };\n  }\n\n  // Extract header (text after WEBVTT on first line)\n  const headerText = firstLine.substring(WEBVTT_SIGNATURE.length).trim();\n  const header = headerText.startsWith('-') || headerText.startsWith(' ')\n    ? headerText.substring(1).trim()\n    : headerText || undefined;\n\n  // Parse the rest of the file\n  const result: VTTFile = {\n    header,\n    cues: [],\n    styles: [],\n    regions: [],\n    notes: [],\n  };\n\n  let currentIndex = 1;\n  let cueCount = 0;\n\n  // Skip empty lines after header\n  while (currentIndex < lines.length && lines[currentIndex].trim() === '') {\n    currentIndex++;\n  }\n\n  // Parse blocks\n  while (currentIndex < lines.length) {\n    const line = lines[currentIndex].trim();\n\n    // Skip empty lines\n    if (line === '') {\n      currentIndex++;\n      continue;\n    }\n\n    // Check for STYLE block\n    if (PATTERNS.styleStart.test(line)) {\n      const styleResult = parseStyleBlock(lines, currentIndex);\n      if (styleResult.style) {\n        result.styles!.push(styleResult.style);\n      }\n      currentIndex = styleResult.nextIndex;\n      continue;\n    }\n\n    // Check for REGION block\n    if (PATTERNS.regionStart.test(line)) {\n      const regionResult = parseRegionBlock(lines, currentIndex);\n      if (regionResult.region) {\n        result.regions!.push(regionResult.region);\n      }\n      currentIndex = regionResult.nextIndex;\n      continue;\n    }\n\n    // Check for NOTE block\n    if (PATTERNS.noteStart.test(line)) {\n      const noteResult = parseNoteBlock(lines, currentIndex);\n      if (noteResult.note) {\n        result.notes!.push(noteResult.note);\n      }\n      currentIndex = noteResult.nextIndex;\n      continue;\n    }\n\n    // Try to parse as a cue\n    const cueResult = parseCue(lines, currentIndex);\n    if (cueResult.cue) {\n      result.cues.push(cueResult.cue);\n      cueCount++;\n    } else if (cueResult.error) {\n      warnings.push(`Line ${currentIndex + 1}: ${cueResult.error}`);\n    }\n    currentIndex = cueResult.nextIndex;\n  }\n\n  // Clean up empty arrays\n  if (result.styles!.length === 0) delete result.styles;\n  if (result.regions!.length === 0) delete result.regions;\n  if (result.notes!.length === 0) delete result.notes;\n\n  log('info', `Parsed ${cueCount} cues from WebVTT file`);\n\n  return {\n    success: true,\n    data: result,\n    warnings: warnings.length > 0 ? warnings : undefined,\n  };\n}\n\n/**\n * Parse a style block\n */\nfunction parseStyleBlock(\n  lines: string[],\n  startIndex: number\n): { style: string | null; nextIndex: number } {\n  let index = startIndex + 1;\n  const styleLines: string[] = [];\n\n  // Collect lines until empty line or end of file\n  while (index < lines.length && lines[index].trim() !== '') {\n    styleLines.push(lines[index]);\n    index++;\n  }\n\n  return {\n    style: styleLines.length > 0 ? styleLines.join('\\n') : null,\n    nextIndex: index,\n  };\n}\n\n/**\n * Parse a region block\n */\nfunction parseRegionBlock(\n  lines: string[],\n  startIndex: number\n): { region: VTTRegion | null; nextIndex: number } {\n  let index = startIndex + 1;\n  const regionLines: string[] = [];\n  let regionId = '';\n\n  // Collect lines until empty line or end of file\n  while (index < lines.length && lines[index].trim() !== '') {\n    const line = lines[index].trim();\n\n    // Extract region ID (WebVTT uses colon-separated key:value pairs)\n    // Region settings can be space-separated on a line, e.g., \"id:region1 width:50%\"\n    const idMatch = line.match(/(?:^|\\s)id:([^\\s]+)/);\n    if (idMatch) {\n      regionId = idMatch[1];\n    }\n\n    regionLines.push(line);\n    index++;\n  }\n\n  if (!regionId) {\n    return { region: null, nextIndex: index };\n  }\n\n  return {\n    region: {\n      id: regionId,\n      settings: regionLines.join('\\n'),\n    },\n    nextIndex: index,\n  };\n}\n\n/**\n * Parse a note block\n */\nfunction parseNoteBlock(\n  lines: string[],\n  startIndex: number\n): { note: string | null; nextIndex: number } {\n  const firstLine = lines[startIndex];\n  let index = startIndex + 1;\n  const noteLines: string[] = [];\n\n  // Check if note content is on the same line as NOTE\n  const inlineNote = firstLine.substring(4).trim();\n  if (inlineNote) {\n    noteLines.push(inlineNote);\n  }\n\n  // Collect additional lines until empty line\n  while (index < lines.length && lines[index].trim() !== '') {\n    noteLines.push(lines[index]);\n    index++;\n  }\n\n  return {\n    note: noteLines.length > 0 ? noteLines.join('\\n') : null,\n    nextIndex: index,\n  };\n}\n\n/**\n * Parse a cue block\n */\nfunction parseCue(\n  lines: string[],\n  startIndex: number\n): { cue: VTTCue | null; error?: string; nextIndex: number } {\n  let index = startIndex;\n  let cueId: string | undefined;\n\n  const currentLine = lines[index]?.trim() || '';\n\n  // Check if this line is a cue ID (doesn't contain -->)\n  if (!currentLine.includes(TIMESTAMP_ARROW)) {\n    // This might be a cue ID\n    cueId = currentLine;\n    index++;\n\n    // Skip if we've run out of lines\n    if (index >= lines.length) {\n      return {\n        cue: null,\n        error: 'Unexpected end of file after cue ID',\n        nextIndex: index,\n      };\n    }\n  }\n\n  // Parse timing line\n  const timingLine = lines[index]?.trim() || '';\n  const timingMatch = timingLine.match(PATTERNS.cueTiming);\n\n  if (!timingMatch) {\n    // Not a valid cue timing line, skip this block\n    // Find next empty line\n    while (index < lines.length && lines[index].trim() !== '') {\n      index++;\n    }\n    return {\n      cue: null,\n      error: `Invalid cue timing: \"${timingLine}\"`,\n      nextIndex: index,\n    };\n  }\n\n  const [, startTimeStr, endTimeStr, settings] = timingMatch;\n\n  const startTime = parseTimestamp(startTimeStr);\n  const endTime = parseTimestamp(endTimeStr);\n\n  if (!startTime || !endTime) {\n    // Find next empty line\n    while (index < lines.length && lines[index].trim() !== '') {\n      index++;\n    }\n    return {\n      cue: null,\n      error: `Invalid timestamps in: \"${timingLine}\"`,\n      nextIndex: index,\n    };\n  }\n\n  // Validate that start time is before end time\n  if (compareTimestamps(startTime, endTime) >= 0) {\n    log('warn', `Cue start time >= end time: ${startTimeStr} --> ${endTimeStr}`);\n    // Continue parsing but log warning\n  }\n\n  index++;\n\n  // Parse cue text (may be multiple lines)\n  const textLines: string[] = [];\n  while (index < lines.length && lines[index].trim() !== '') {\n    textLines.push(lines[index]);\n    index++;\n  }\n\n  const text = textLines.join('\\n');\n\n  if (!text) {\n    log('debug', 'Empty cue text');\n  }\n\n  const cue: VTTCue = {\n    startTime,\n    endTime,\n    text,\n  };\n\n  if (cueId) {\n    cue.id = cueId;\n  }\n\n  if (settings) {\n    cue.settings = settings;\n  }\n\n  return { cue, nextIndex: index };\n}\n\n// ============================================\n// Utility Functions\n// ============================================\n\n/**\n * Check if a string is valid WebVTT content\n */\nexport function isValidVTT(content: string): boolean {\n  if (!content || typeof content !== 'string') {\n    return false;\n  }\n\n  const stripped = content.replace(PATTERNS.bom, '').trim();\n  return stripped.startsWith(WEBVTT_SIGNATURE);\n}\n\n/**\n * Extract plain text from a cue (removing VTT formatting tags)\n *\n * @param text - Cue text potentially containing VTT tags\n * @returns Plain text without tags\n */\nexport function stripVTTTags(text: string): string {\n  // Remove VTT tags like <v Name>, <c.class>, <b>, <i>, <u>, <ruby>, <rt>, <lang>\n  // Also handles <00:00:00.000> timestamp tags\n  return text\n    .replace(/<\\/?[^>]+>/g, '') // Remove all tags\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&lrm;/g, '\\u200E')\n    .replace(/&rlm;/g, '\\u200F');\n}\n\n/**\n * Get the total duration of a VTT file based on the last cue's end time\n */\nexport function getVTTDuration(vttFile: VTTFile): number {\n  if (vttFile.cues.length === 0) {\n    return 0;\n  }\n\n  let maxEndTime = 0;\n  for (const cue of vttFile.cues) {\n    const endMs = timestampToMs(cue.endTime);\n    if (endMs > maxEndTime) {\n      maxEndTime = endMs;\n    }\n  }\n\n  return maxEndTime;\n}\n\n/**\n * Get cue at a specific time\n *\n * @param vttFile - Parsed VTT file\n * @param timeMs - Time in milliseconds\n * @returns Cue(s) active at the specified time\n */\nexport function getCuesAtTime(vttFile: VTTFile, timeMs: number): VTTCue[] {\n  return vttFile.cues.filter((cue) => {\n    const start = timestampToMs(cue.startTime);\n    const end = timestampToMs(cue.endTime);\n    return timeMs >= start && timeMs < end;\n  });\n}\n\n// ============================================\n// Exports\n// ============================================\n\nexport default {\n  parseVTT,\n  parseTimestamp,\n  timestampToMs,\n  msToTimestamp,\n  compareTimestamps,\n  isValidVTT,\n  stripVTTTags,\n  getVTTDuration,\n  getCuesAtTime,\n  setLogLevel,\n};\n", "/**\n * WebVTT Generator Module\n *\n * Generates WebVTT (Web Video Text Tracks) files from structured data.\n * Produces valid WebVTT output that can be used directly in browsers.\n *\n * Task ID: T-20251223-act-006-build-webvtt-parser\n *\n * Acceptance Criteria:\n * - [x] \u751F\u6210\u5668\u53EF\u5C06\u89E3\u6790\u7ED3\u679C\u8FD8\u539F\u4E3A\u6709\u6548 WebVTT \u5B57\u7B26\u4E32\n * - [x] \u89E3\u6790\u540E\u518D\u751F\u6210\u7684\u6587\u4EF6\u4E0E\u539F\u6587\u4EF6\u8BED\u4E49\u7B49\u4EF7\n *\n * @see https://www.w3.org/TR/webvtt1/\n */\n\nimport type {\n  VTTTimestamp,\n  VTTCue,\n  VTTFile,\n  VTTGeneratorOptions,\n} from '../types';\n\n// ============================================\n// Constants\n// ============================================\n\n/** Logger prefix */\nconst LOG_PREFIX = '[WebVTT Generator]';\n\n/** WebVTT file signature */\nconst WEBVTT_SIGNATURE = 'WEBVTT';\n\n/** Default generator options */\nconst DEFAULT_OPTIONS: VTTGeneratorOptions = {\n  includeCueIds: true,\n  includeStyles: true,\n  includeRegions: true,\n  includeNotes: true,\n  useShortTimestamp: false,\n};\n\n// ============================================\n// Logger\n// ============================================\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nlet currentLogLevel: LogLevel = 'warn';\n\nfunction log(level: LogLevel, ...args: unknown[]): void {\n  if (LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel]) {\n    const method = level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log';\n    console[method](LOG_PREFIX, `[${level.toUpperCase()}]`, ...args);\n  }\n}\n\n/**\n * Set the logging level for the generator\n */\nexport function setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n// ============================================\n// Timestamp Formatting\n// ============================================\n\n/**\n * Format a VTTTimestamp to string\n *\n * @param timestamp - Timestamp object to format\n * @param useShort - Use short format (MM:SS.mmm) when hours is 0\n * @returns Formatted timestamp string\n */\nexport function formatTimestamp(\n  timestamp: VTTTimestamp,\n  useShort: boolean = false\n): string {\n  const { hours, minutes, seconds, milliseconds } = timestamp;\n\n  const mm = minutes.toString().padStart(2, '0');\n  const ss = seconds.toString().padStart(2, '0');\n  const ms = milliseconds.toString().padStart(3, '0');\n\n  if (useShort && hours === 0) {\n    return `${mm}:${ss}.${ms}`;\n  }\n\n  const hh = hours.toString().padStart(2, '0');\n  return `${hh}:${mm}:${ss}.${ms}`;\n}\n\n/**\n * Create a VTTTimestamp from individual components\n */\nexport function createTimestamp(\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number\n): VTTTimestamp {\n  return { hours, minutes, seconds, milliseconds };\n}\n\n/**\n * Create a VTTTimestamp from total milliseconds\n */\nexport function timestampFromMs(totalMs: number): VTTTimestamp {\n  const hours = Math.floor(totalMs / 3600000);\n  totalMs %= 3600000;\n  const minutes = Math.floor(totalMs / 60000);\n  totalMs %= 60000;\n  const seconds = Math.floor(totalMs / 1000);\n  const milliseconds = totalMs % 1000;\n\n  return { hours, minutes, seconds, milliseconds };\n}\n\n// ============================================\n// Cue Generation\n// ============================================\n\n/**\n * Generate a single cue block\n *\n * @param cue - Cue object to generate\n * @param options - Generator options\n * @returns Cue block string\n */\nexport function generateCue(\n  cue: VTTCue,\n  options: VTTGeneratorOptions = DEFAULT_OPTIONS\n): string {\n  const lines: string[] = [];\n\n  // Add cue ID if present and option enabled\n  if (cue.id && options.includeCueIds !== false) {\n    lines.push(cue.id);\n  }\n\n  // Format timing line\n  const startTime = formatTimestamp(cue.startTime, options.useShortTimestamp);\n  const endTime = formatTimestamp(cue.endTime, options.useShortTimestamp);\n\n  let timingLine = `${startTime} --> ${endTime}`;\n\n  // Add cue settings if present\n  if (cue.settings) {\n    timingLine += ` ${cue.settings}`;\n  }\n\n  lines.push(timingLine);\n\n  // Add cue text\n  if (cue.text) {\n    lines.push(cue.text);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Create a new VTTCue object\n */\nexport function createCue(\n  startTime: VTTTimestamp,\n  endTime: VTTTimestamp,\n  text: string,\n  id?: string,\n  settings?: string\n): VTTCue {\n  const cue: VTTCue = {\n    startTime,\n    endTime,\n    text,\n  };\n\n  if (id) {\n    cue.id = id;\n  }\n\n  if (settings) {\n    cue.settings = settings;\n  }\n\n  return cue;\n}\n\n// ============================================\n// Main Generator\n// ============================================\n\n/**\n * Generate a complete WebVTT file string from structured data\n *\n * @param vttFile - Parsed VTT file structure\n * @param options - Generator options\n * @returns WebVTT file content string\n */\nexport function generateVTT(\n  vttFile: VTTFile,\n  options: VTTGeneratorOptions = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const lines: string[] = [];\n\n  // Generate header line\n  let headerLine = WEBVTT_SIGNATURE;\n  if (vttFile.header) {\n    headerLine += ` ${vttFile.header}`;\n  }\n  lines.push(headerLine);\n  lines.push(''); // Empty line after header\n\n  // Generate style blocks\n  if (opts.includeStyles && vttFile.styles && vttFile.styles.length > 0) {\n    for (const style of vttFile.styles) {\n      lines.push('STYLE');\n      lines.push(style);\n      lines.push('');\n    }\n  }\n\n  // Generate region blocks\n  if (opts.includeRegions && vttFile.regions && vttFile.regions.length > 0) {\n    for (const region of vttFile.regions) {\n      lines.push('REGION');\n      lines.push(region.settings);\n      lines.push('');\n    }\n  }\n\n  // Generate notes (if option enabled)\n  if (opts.includeNotes && vttFile.notes && vttFile.notes.length > 0) {\n    for (const note of vttFile.notes) {\n      lines.push(`NOTE ${note}`);\n      lines.push('');\n    }\n  }\n\n  // Generate cues\n  for (let i = 0; i < vttFile.cues.length; i++) {\n    const cue = vttFile.cues[i];\n    lines.push(generateCue(cue, opts));\n\n    // Add empty line between cues (but not after the last one)\n    if (i < vttFile.cues.length - 1) {\n      lines.push('');\n    }\n  }\n\n  log('info', `Generated WebVTT with ${vttFile.cues.length} cues`);\n\n  return lines.join('\\n');\n}\n\n/**\n * Generate a minimal WebVTT file from an array of cues\n *\n * @param cues - Array of cues\n * @param header - Optional header text\n * @returns WebVTT file content string\n */\nexport function generateFromCues(\n  cues: VTTCue[],\n  header?: string\n): string {\n  const vttFile: VTTFile = {\n    header,\n    cues,\n  };\n\n  return generateVTT(vttFile);\n}\n\n/**\n * Generate a WebVTT data URI for use in <track> elements\n *\n * @param vttFile - VTT file structure or string content\n * @returns Data URI string\n */\nexport function generateDataUri(\n  vttFile: VTTFile | string\n): string {\n  const content = typeof vttFile === 'string' ? vttFile : generateVTT(vttFile);\n\n  // Encode as base64\n  const base64 = typeof btoa === 'function'\n    ? btoa(unescape(encodeURIComponent(content)))\n    : Buffer.from(content, 'utf-8').toString('base64');\n\n  return `data:text/vtt;base64,${base64}`;\n}\n\n/**\n * Generate a Blob URL for use in <track> elements\n * Note: This function only works in browser environments\n *\n * @param vttFile - VTT file structure or string content\n * @returns Blob URL string\n */\nexport function generateBlobUrl(\n  vttFile: VTTFile | string\n): string {\n  if (typeof Blob === 'undefined' || typeof URL === 'undefined') {\n    throw new Error('Blob URLs are not supported in this environment');\n  }\n\n  const content = typeof vttFile === 'string' ? vttFile : generateVTT(vttFile);\n  const blob = new Blob([content], { type: 'text/vtt' });\n  return URL.createObjectURL(blob);\n}\n\n// ============================================\n// Helper Functions\n// ============================================\n\n/**\n * Clone a VTTFile with replaced cue texts\n *\n * This is useful for translation: keep all timing and structure,\n * but replace the text content of cues.\n *\n * @param original - Original VTT file\n * @param newTexts - Array of new text content (must match cue count)\n * @returns New VTTFile with replaced texts\n */\nexport function replaceCueTexts(\n  original: VTTFile,\n  newTexts: string[]\n): VTTFile {\n  if (newTexts.length !== original.cues.length) {\n    log('warn', `Text count (${newTexts.length}) doesn't match cue count (${original.cues.length})`);\n  }\n\n  const newCues: VTTCue[] = original.cues.map((cue, index) => ({\n    ...cue,\n    text: index < newTexts.length ? newTexts[index] : cue.text,\n  }));\n\n  return {\n    ...original,\n    cues: newCues,\n  };\n}\n\n/**\n * Merge multiple VTT files into one\n *\n * @param files - Array of VTT files to merge\n * @returns Merged VTT file\n */\nexport function mergeVTTFiles(files: VTTFile[]): VTTFile {\n  if (files.length === 0) {\n    return { cues: [] };\n  }\n\n  const merged: VTTFile = {\n    header: files[0].header,\n    cues: [],\n    styles: [],\n    regions: [],\n    notes: [],\n  };\n\n  for (const file of files) {\n    merged.cues.push(...file.cues);\n\n    if (file.styles) {\n      merged.styles!.push(...file.styles);\n    }\n    if (file.regions) {\n      merged.regions!.push(...file.regions);\n    }\n    if (file.notes) {\n      merged.notes!.push(...file.notes);\n    }\n  }\n\n  // Sort cues by start time\n  merged.cues.sort((a, b) => {\n    const aMs =\n      a.startTime.hours * 3600000 +\n      a.startTime.minutes * 60000 +\n      a.startTime.seconds * 1000 +\n      a.startTime.milliseconds;\n    const bMs =\n      b.startTime.hours * 3600000 +\n      b.startTime.minutes * 60000 +\n      b.startTime.seconds * 1000 +\n      b.startTime.milliseconds;\n    return aMs - bMs;\n  });\n\n  // Clean up empty arrays\n  if (merged.styles!.length === 0) delete merged.styles;\n  if (merged.regions!.length === 0) delete merged.regions;\n  if (merged.notes!.length === 0) delete merged.notes;\n\n  return merged;\n}\n\n/**\n * Extract all cue texts as an array\n *\n * @param vttFile - VTT file\n * @returns Array of cue text strings\n */\nexport function extractCueTexts(vttFile: VTTFile): string[] {\n  return vttFile.cues.map((cue) => cue.text);\n}\n\n/**\n * Validate that a VTTFile structure is well-formed\n *\n * @param vttFile - VTT file to validate\n * @returns Validation result with any errors\n */\nexport function validateVTTFile(vttFile: VTTFile): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (!vttFile) {\n    return { valid: false, errors: ['VTT file is null or undefined'] };\n  }\n\n  if (!Array.isArray(vttFile.cues)) {\n    return { valid: false, errors: ['VTT file has no cues array'] };\n  }\n\n  for (let i = 0; i < vttFile.cues.length; i++) {\n    const cue = vttFile.cues[i];\n    const cuePrefix = `Cue ${i + 1}${cue.id ? ` (${cue.id})` : ''}`;\n\n    if (!cue.startTime || !cue.endTime) {\n      errors.push(`${cuePrefix}: missing start or end time`);\n      continue;\n    }\n\n    // Validate timestamp components\n    const { startTime, endTime } = cue;\n\n    if (\n      startTime.hours < 0 ||\n      startTime.minutes < 0 ||\n      startTime.minutes > 59 ||\n      startTime.seconds < 0 ||\n      startTime.seconds > 59 ||\n      startTime.milliseconds < 0 ||\n      startTime.milliseconds > 999\n    ) {\n      errors.push(`${cuePrefix}: invalid start timestamp`);\n    }\n\n    if (\n      endTime.hours < 0 ||\n      endTime.minutes < 0 ||\n      endTime.minutes > 59 ||\n      endTime.seconds < 0 ||\n      endTime.seconds > 59 ||\n      endTime.milliseconds < 0 ||\n      endTime.milliseconds > 999\n    ) {\n      errors.push(`${cuePrefix}: invalid end timestamp`);\n    }\n\n    // Check that start time is before end time\n    const startMs =\n      startTime.hours * 3600000 +\n      startTime.minutes * 60000 +\n      startTime.seconds * 1000 +\n      startTime.milliseconds;\n    const endMs =\n      endTime.hours * 3600000 +\n      endTime.minutes * 60000 +\n      endTime.seconds * 1000 +\n      endTime.milliseconds;\n\n    if (startMs >= endMs) {\n      errors.push(`${cuePrefix}: start time >= end time`);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n// ============================================\n// Exports\n// ============================================\n\nexport default {\n  generateVTT,\n  generateCue,\n  generateFromCues,\n  generateDataUri,\n  generateBlobUrl,\n  formatTimestamp,\n  createTimestamp,\n  timestampFromMs,\n  createCue,\n  replaceCueTexts,\n  mergeVTTFiles,\n  extractCueTexts,\n  validateVTTFile,\n  setLogLevel,\n};\n", "/**\n * Cost Estimator Utilities\n *\n * Task ID: T-20251223-act-016-build-cost-estimate\n *\n * Converts token usage to an estimated USD cost based on a simple per-1K-tokens pricing table.\n * Note: Prices are approximate and should be kept in sync with the models exposed in the UI.\n */\n\nexport const DEFAULT_COST_PER_1K_TOKENS_USD = 0.005;\n\n/**\n * Model pricing (USD per 1K tokens).\n *\n * The translator treats prompt+completion tokens the same for estimation purposes.\n */\nexport const MODEL_COST_PER_1K_TOKENS_USD: Record<string, number> = {\n  // OpenAI GPT-5 series\n  'gpt-5.2': 0.01,\n  'gpt-5.1': 0.008,\n  'gpt-5-pro': 0.015,\n  'gpt-5': 0.006,\n\n  // Gemini 3.x / 2.5 series\n  'gemini-3-pro-preview': 0.005,\n  'gemini-3-flash-preview': 0.001,\n  'gemini-2.5-pro': 0.003,\n  'gemini-2.5-flash': 0.0005,\n};\n\nexport function getCostPer1kTokensUSD(model: string): number {\n  return MODEL_COST_PER_1K_TOKENS_USD[model] ?? DEFAULT_COST_PER_1K_TOKENS_USD;\n}\n\nexport function calculateCost(model: string, tokenCount: number): number {\n  const pricePerK = getCostPer1kTokensUSD(model);\n  return (tokenCount / 1000) * pricePerK;\n}\n\n", "/**\n * OpenAI API Client Module\n *\n * Provides a client for calling OpenAI Chat Completions API with streaming support.\n * Designed to work in Chrome Extension Service Worker environment with keepalive mechanism.\n *\n * Task ID: T-20251223-act-007-build-llm-translator\n *\n * Features:\n * - Streaming API support (avoids 30s fetch timeout)\n * - Service Worker keepalive mechanism\n * - Timeout handling (configurable, default 60s)\n * - Error handling and retry support\n *\n * @see https://platform.openai.com/docs/api-reference/chat\n */\n\n// ============================================\n// Types\n// ============================================\n\n/**\n * OpenAI API request message\n */\nexport interface OpenAIMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n}\n\n/**\n * OpenAI API request options\n */\nexport interface OpenAIRequestOptions {\n  /** API Key */\n  apiKey: string;\n  /** Model to use */\n  model: string;\n  /** Messages for the conversation */\n  messages: OpenAIMessage[];\n  /** Maximum tokens in response */\n  maxTokens?: number;\n  /** Request timeout in milliseconds (default 60000) */\n  timeout?: number;\n  /** Enable streaming (default true) */\n  stream?: boolean;\n  /** Abort signal for cancellation */\n  signal?: AbortSignal;\n}\n\n/**\n * OpenAI API response\n */\nexport interface OpenAIResponse {\n  /** Whether the request succeeded */\n  success: boolean;\n  /** Response content */\n  content?: string;\n  /** Error message if failed */\n  error?: string;\n  /** Error code */\n  errorCode?: string;\n  /** Prompt tokens used */\n  promptTokens?: number;\n  /** Completion tokens used */\n  completionTokens?: number;\n  /** Total tokens used */\n  totalTokens?: number;\n  /** Model used */\n  model?: string;\n  /** Finish reason */\n  finishReason?: string;\n}\n\n/**\n * Streaming chunk from OpenAI\n */\ninterface StreamDelta {\n  content?: string;\n}\n\n/**\n * Streaming response chunk\n */\ninterface StreamChunk {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: Array<{\n    index: number;\n    delta: StreamDelta;\n    finish_reason: string | null;\n  }>;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\n// ============================================\n// Constants\n// ============================================\n\nconst LOG_PREFIX = '[OpenAI Client]';\nconst OPENAI_API_BASE = 'https://api.openai.com/v1';\nconst DEFAULT_TIMEOUT = 60000; // 60 seconds\nconst KEEPALIVE_INTERVAL = 25000; // 25 seconds (under 30s SW idle timeout)\n\n// ============================================\n// Logger\n// ============================================\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nlet currentLogLevel: LogLevel = 'info';\n\nfunction log(level: LogLevel, ...args: unknown[]): void {\n  if (LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel]) {\n    const method = level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log';\n    console[method](LOG_PREFIX, `[${level.toUpperCase()}]`, ...args);\n  }\n}\n\n/**\n * Set the logging level\n */\nexport function setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n// ============================================\n// Service Worker Keepalive\n// ============================================\n\nlet keepaliveTimer: ReturnType<typeof setInterval> | null = null;\n\n/**\n * Start the keepalive timer to prevent Service Worker from sleeping\n * Uses chrome.runtime.getPlatformInfo as a lightweight API call\n */\nfunction startKeepalive(): void {\n  if (keepaliveTimer) return;\n\n  keepaliveTimer = setInterval(() => {\n    // Use chrome API if available (Chrome Extension environment)\n    if (typeof chrome !== 'undefined' && chrome.runtime?.getPlatformInfo) {\n      chrome.runtime.getPlatformInfo(() => {\n        log('debug', 'Keepalive ping');\n      });\n    }\n  }, KEEPALIVE_INTERVAL);\n\n  log('debug', 'Keepalive timer started');\n}\n\n/**\n * Stop the keepalive timer\n */\nfunction stopKeepalive(): void {\n  if (keepaliveTimer) {\n    clearInterval(keepaliveTimer);\n    keepaliveTimer = null;\n    log('debug', 'Keepalive timer stopped');\n  }\n}\n\n// ============================================\n// Main API Functions\n// ============================================\n\n/**\n * Call OpenAI Chat Completions API with streaming\n *\n * @param options - Request options\n * @returns API response\n */\nexport async function chatCompletion(options: OpenAIRequestOptions): Promise<OpenAIResponse> {\n  const {\n    apiKey,\n    model,\n    messages,\n    maxTokens,\n    timeout = DEFAULT_TIMEOUT,\n    stream = true,\n    signal,\n  } = options;\n\n  // Validate inputs\n  if (!apiKey) {\n    return { success: false, error: 'API key is required', errorCode: 'MISSING_API_KEY' };\n  }\n\n  if (!model) {\n    return { success: false, error: 'Model is required', errorCode: 'MISSING_MODEL' };\n  }\n\n  if (!messages || messages.length === 0) {\n    return { success: false, error: 'Messages are required', errorCode: 'MISSING_MESSAGES' };\n  }\n\n  // Build request body - simple, like a ChatGPT conversation\n  const requestBody: Record<string, unknown> = {\n    model,\n    messages,\n    stream,\n    stream_options: stream ? { include_usage: true } : undefined,\n  };\n\n  if (maxTokens) {\n    requestBody.max_tokens = maxTokens;\n  }\n\n  // Create abort controller for timeout\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n  // Combine with external signal if provided\n  if (signal) {\n    signal.addEventListener('abort', () => controller.abort(), { once: true });\n  }\n\n  // Start keepalive for long-running requests\n  startKeepalive();\n\n  try {\n    log('info', `Calling OpenAI API with model: ${model}`);\n\n    const response = await fetch(`${OPENAI_API_BASE}/chat/completions`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify(requestBody),\n      signal: controller.signal,\n    });\n\n    // Handle HTTP errors\n    if (!response.ok) {\n      const errorBody = await response.text();\n      let errorMessage = `HTTP ${response.status}: ${response.statusText}`;\n      let errorCode = `HTTP_${response.status}`;\n\n      try {\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error?.message) {\n          errorMessage = errorJson.error.message;\n          errorCode = errorJson.error.code || errorCode;\n        }\n      } catch {\n        // Use default error message\n      }\n\n      log('error', 'API error:', errorMessage);\n\n      // Provide user-friendly messages for common errors\n      if (response.status === 401) {\n        errorMessage = 'Invalid API key. Please check your OpenAI API key.';\n        errorCode = 'INVALID_API_KEY';\n      } else if (response.status === 429) {\n        errorMessage = 'Rate limit exceeded. Please try again later.';\n        errorCode = 'RATE_LIMIT';\n      } else if (response.status === 500 || response.status === 503) {\n        errorMessage = 'OpenAI service is temporarily unavailable. Please try again.';\n        errorCode = 'SERVICE_UNAVAILABLE';\n      }\n\n      return { success: false, error: errorMessage, errorCode };\n    }\n\n    // Handle streaming response\n    if (stream) {\n      return await handleStreamingResponse(response, model);\n    }\n\n    // Handle non-streaming response\n    const data = await response.json();\n    return {\n      success: true,\n      content: data.choices?.[0]?.message?.content || '',\n      promptTokens: data.usage?.prompt_tokens,\n      completionTokens: data.usage?.completion_tokens,\n      totalTokens: data.usage?.total_tokens,\n      model: data.model,\n      finishReason: data.choices?.[0]?.finish_reason,\n    };\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.name === 'AbortError') {\n        log('warn', 'Request aborted or timed out');\n        return { success: false, error: 'Request timed out or was cancelled', errorCode: 'TIMEOUT' };\n      }\n\n      log('error', 'Request failed:', error.message);\n      return { success: false, error: error.message, errorCode: 'NETWORK_ERROR' };\n    }\n\n    return { success: false, error: 'Unknown error occurred', errorCode: 'UNKNOWN_ERROR' };\n  } finally {\n    clearTimeout(timeoutId);\n    stopKeepalive();\n  }\n}\n\n/**\n * Handle streaming response from OpenAI\n */\nasync function handleStreamingResponse(\n  response: Response,\n  requestModel: string\n): Promise<OpenAIResponse> {\n  const reader = response.body?.getReader();\n  if (!reader) {\n    return { success: false, error: 'No response body', errorCode: 'NO_RESPONSE_BODY' };\n  }\n\n  const decoder = new TextDecoder();\n  let content = '';\n  let promptTokens: number | undefined;\n  let completionTokens: number | undefined;\n  let totalTokens: number | undefined;\n  let model = requestModel;\n  let finishReason: string | undefined;\n\n  try {\n    let buffer = '';\n\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        break;\n      }\n\n      buffer += decoder.decode(value, { stream: true });\n\n      // Process complete SSE events\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n      for (const line of lines) {\n        const trimmed = line.trim();\n\n        if (!trimmed || trimmed === 'data: [DONE]') {\n          continue;\n        }\n\n        if (trimmed.startsWith('data: ')) {\n          const jsonStr = trimmed.slice(6);\n          try {\n            const chunk = JSON.parse(jsonStr) as StreamChunk;\n\n            // Extract content delta\n            const delta = chunk.choices?.[0]?.delta?.content;\n            if (delta) {\n              content += delta;\n            }\n\n            // Extract finish reason\n            const reason = chunk.choices?.[0]?.finish_reason;\n            if (reason) {\n              finishReason = reason;\n            }\n\n            // Extract usage from final chunk (when stream_options.include_usage is true)\n            if (chunk.usage) {\n              promptTokens = chunk.usage.prompt_tokens;\n              completionTokens = chunk.usage.completion_tokens;\n              totalTokens = chunk.usage.total_tokens;\n            }\n\n            // Extract model\n            if (chunk.model) {\n              model = chunk.model;\n            }\n          } catch (parseError) {\n            log('debug', 'Failed to parse chunk:', jsonStr);\n          }\n        }\n      }\n    }\n\n    log('info', `Streaming complete. Received ${content.length} characters`);\n\n    return {\n      success: true,\n      content,\n      promptTokens,\n      completionTokens,\n      totalTokens,\n      model,\n      finishReason,\n    };\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      log('warn', 'Streaming aborted or timed out');\n      return { success: false, error: 'Request timed out or was cancelled', errorCode: 'TIMEOUT' };\n    }\n\n    const message = error instanceof Error ? error.message : String(error);\n    const normalized = message.toLowerCase();\n    if (normalized.includes('network error')) {\n      log('warn', 'Streaming network error:', error);\n      return {\n        success: false,\n        error: 'Network error while streaming response (check VPN/firewall or blocking extensions)',\n        errorCode: 'NETWORK_ERROR',\n      };\n    }\n\n    log('warn', 'Streaming error:', error);\n    return {\n      success: false,\n      error: message || 'Streaming failed',\n      errorCode: 'STREAMING_ERROR',\n    };\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * Validate an OpenAI API key by making a test request\n *\n * @param apiKey - API key to validate\n * @returns Validation result\n */\nexport async function validateApiKey(apiKey: string): Promise<{\n  valid: boolean;\n  error?: string;\n  models?: string[];\n}> {\n  try {\n    const response = await fetch(`${OPENAI_API_BASE}/models`, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${apiKey}`,\n      },\n    });\n\n    if (!response.ok) {\n      if (response.status === 401) {\n        return { valid: false, error: 'Invalid API key' };\n      }\n      return { valid: false, error: `HTTP ${response.status}: ${response.statusText}` };\n    }\n\n    const data = await response.json();\n    const models = data.data\n      ?.filter((m: { id: string }) => m.id.startsWith('gpt'))\n      ?.map((m: { id: string }) => m.id) || [];\n\n    return { valid: true, models };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error instanceof Error ? error.message : 'Validation failed',\n    };\n  }\n}\n\n/**\n * Estimate token count for a string (rough approximation)\n * Uses the rule of thumb: ~4 characters per token for English\n *\n * @param text - Text to estimate\n * @returns Estimated token count\n */\nexport function estimateTokens(text: string): number {\n  // For CJK characters, use ~1.5 tokens per character\n  // For other text, use ~4 characters per token\n  const cjkChars = text.match(/[\\u4e00-\\u9fff\\u3400-\\u4dbf\\u3000-\\u303f]/g)?.length || 0;\n  const otherChars = text.length - cjkChars;\n\n  return Math.ceil(cjkChars * 1.5 + otherChars / 4);\n}\n\n// ============================================\n// Exports\n// ============================================\n\nexport default {\n  chatCompletion,\n  validateApiKey,\n  estimateTokens,\n  setLogLevel,\n};\n", "/**\n * Google Gemini API Client Module\n *\n * Provides a client for calling Google Gemini API with streaming support.\n * Designed to work in Chrome Extension Service Worker environment with keepalive mechanism.\n *\n * Task ID: T-20251223-act-007-build-llm-translator\n *\n * Features:\n * - Streaming API support (avoids 30s fetch timeout)\n * - Service Worker keepalive mechanism\n * - Timeout handling (configurable, default 60s)\n * - Error handling and retry support\n *\n * @see https://ai.google.dev/gemini-api/docs/text-generation\n */\n\n// ============================================\n// Types\n// ============================================\n\n/**\n * Gemini content part\n */\nexport interface GeminiPart {\n  text: string;\n}\n\n/**\n * Gemini content (message)\n */\nexport interface GeminiContent {\n  role: 'user' | 'model';\n  parts: GeminiPart[];\n}\n\n/**\n * Gemini API request options\n */\nexport interface GeminiRequestOptions {\n  /** API Key */\n  apiKey: string;\n  /** Model to use */\n  model: string;\n  /** System instruction */\n  systemInstruction?: string;\n  /** Conversation contents */\n  contents: GeminiContent[];\n  /** Maximum tokens in response */\n  maxOutputTokens?: number;\n  /** Request timeout in milliseconds (default 60000) */\n  timeout?: number;\n  /** Enable streaming (default true) */\n  stream?: boolean;\n  /** Abort signal for cancellation */\n  signal?: AbortSignal;\n}\n\n/**\n * Gemini API response\n */\nexport interface GeminiResponse {\n  /** Whether the request succeeded */\n  success: boolean;\n  /** Response content */\n  content?: string;\n  /** Error message if failed */\n  error?: string;\n  /** Error code */\n  errorCode?: string;\n  /** Prompt tokens used */\n  promptTokens?: number;\n  /** Completion tokens used */\n  completionTokens?: number;\n  /** Total tokens used */\n  totalTokens?: number;\n  /** Model used */\n  model?: string;\n  /** Finish reason */\n  finishReason?: string;\n}\n\n/**\n * Gemini streaming chunk\n */\ninterface GeminiStreamChunk {\n  candidates?: Array<{\n    content?: {\n      parts?: GeminiPart[];\n      role?: string;\n    };\n    finishReason?: string;\n  }>;\n  usageMetadata?: {\n    promptTokenCount?: number;\n    candidatesTokenCount?: number;\n    totalTokenCount?: number;\n  };\n}\n\n// ============================================\n// Constants\n// ============================================\n\nconst LOG_PREFIX = '[Gemini Client]';\nconst GEMINI_API_BASE = 'https://generativelanguage.googleapis.com/v1beta';\nconst DEFAULT_TIMEOUT = 60000; // 60 seconds\nconst KEEPALIVE_INTERVAL = 25000; // 25 seconds (under 30s SW idle timeout)\n\n// ============================================\n// Logger\n// ============================================\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nlet currentLogLevel: LogLevel = 'info';\n\nfunction log(level: LogLevel, ...args: unknown[]): void {\n  if (LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel]) {\n    const method = level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log';\n    console[method](LOG_PREFIX, `[${level.toUpperCase()}]`, ...args);\n  }\n}\n\n/**\n * Set the logging level\n */\nexport function setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n// ============================================\n// Service Worker Keepalive\n// ============================================\n\nlet keepaliveTimer: ReturnType<typeof setInterval> | null = null;\n\n/**\n * Start the keepalive timer to prevent Service Worker from sleeping\n * Uses chrome.runtime.getPlatformInfo as a lightweight API call\n */\nfunction startKeepalive(): void {\n  if (keepaliveTimer) return;\n\n  keepaliveTimer = setInterval(() => {\n    // Use chrome API if available (Chrome Extension environment)\n    if (typeof chrome !== 'undefined' && chrome.runtime?.getPlatformInfo) {\n      chrome.runtime.getPlatformInfo(() => {\n        log('debug', 'Keepalive ping');\n      });\n    }\n  }, KEEPALIVE_INTERVAL);\n\n  log('debug', 'Keepalive timer started');\n}\n\n/**\n * Stop the keepalive timer\n */\nfunction stopKeepalive(): void {\n  if (keepaliveTimer) {\n    clearInterval(keepaliveTimer);\n    keepaliveTimer = null;\n    log('debug', 'Keepalive timer stopped');\n  }\n}\n\n// ============================================\n// Main API Functions\n// ============================================\n\n/**\n * Call Gemini generateContent API with streaming\n *\n * @param options - Request options\n * @returns API response\n */\nexport async function generateContent(options: GeminiRequestOptions): Promise<GeminiResponse> {\n  const {\n    apiKey,\n    model,\n    systemInstruction,\n    contents,\n    maxOutputTokens,\n    timeout = DEFAULT_TIMEOUT,\n    stream = true,\n    signal,\n  } = options;\n\n  // Validate inputs\n  if (!apiKey) {\n    return { success: false, error: 'API key is required', errorCode: 'MISSING_API_KEY' };\n  }\n\n  if (!model) {\n    return { success: false, error: 'Model is required', errorCode: 'MISSING_MODEL' };\n  }\n\n  if (!contents || contents.length === 0) {\n    return { success: false, error: 'Contents are required', errorCode: 'MISSING_CONTENTS' };\n  }\n\n  // Build request body - simple, like a ChatGPT conversation\n  const requestBody: Record<string, unknown> = {\n    contents,\n    ...(maxOutputTokens && {\n      generationConfig: { maxOutputTokens },\n    }),\n  };\n\n  // Add system instruction if provided\n  if (systemInstruction) {\n    requestBody.systemInstruction = {\n      parts: [{ text: systemInstruction }],\n    };\n  }\n\n  // Create abort controller for timeout\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n  // Combine with external signal if provided\n  if (signal) {\n    signal.addEventListener('abort', () => controller.abort());\n  }\n\n  // Start keepalive for long-running requests\n  startKeepalive();\n\n  // Determine endpoint based on streaming\n  const endpoint = stream ? 'streamGenerateContent' : 'generateContent';\n  const url = `${GEMINI_API_BASE}/models/${model}:${endpoint}?key=${apiKey}`;\n\n  try {\n    log('info', `Calling Gemini API with model: ${model}`);\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(requestBody),\n      signal: controller.signal,\n    });\n\n    clearTimeout(timeoutId);\n\n    // Handle HTTP errors\n    if (!response.ok) {\n      const errorBody = await response.text();\n      let errorMessage = `HTTP ${response.status}: ${response.statusText}`;\n      let errorCode = `HTTP_${response.status}`;\n\n      try {\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error?.message) {\n          errorMessage = errorJson.error.message;\n          errorCode = errorJson.error.status || errorCode;\n        }\n      } catch {\n        // Use default error message\n      }\n\n      log('error', 'API error:', errorMessage);\n\n      // Provide user-friendly messages for common errors\n      if (response.status === 400) {\n        if (errorMessage.includes('API_KEY_INVALID') || errorMessage.includes('API key not valid')) {\n          errorMessage = 'Invalid API key. Please check your Gemini API key.';\n          errorCode = 'INVALID_API_KEY';\n        }\n      } else if (response.status === 429) {\n        errorMessage = 'Rate limit exceeded. Please try again later.';\n        errorCode = 'RATE_LIMIT';\n      } else if (response.status === 500 || response.status === 503) {\n        errorMessage = 'Gemini service is temporarily unavailable. Please try again.';\n        errorCode = 'SERVICE_UNAVAILABLE';\n      }\n\n      return { success: false, error: errorMessage, errorCode };\n    }\n\n    // Handle streaming response\n    if (stream) {\n      return await handleStreamingResponse(response, model);\n    }\n\n    // Handle non-streaming response\n    const data = await response.json();\n    const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';\n\n    return {\n      success: true,\n      content: text,\n      promptTokens: data.usageMetadata?.promptTokenCount,\n      completionTokens: data.usageMetadata?.candidatesTokenCount,\n      totalTokens: data.usageMetadata?.totalTokenCount,\n      model,\n      finishReason: data.candidates?.[0]?.finishReason,\n    };\n  } catch (error) {\n    clearTimeout(timeoutId);\n\n    if (error instanceof Error) {\n      if (error.name === 'AbortError') {\n        log('warn', 'Request aborted or timed out');\n        return { success: false, error: 'Request timed out or was cancelled', errorCode: 'TIMEOUT' };\n      }\n\n      log('error', 'Request failed:', error.message);\n      return { success: false, error: error.message, errorCode: 'NETWORK_ERROR' };\n    }\n\n    return { success: false, error: 'Unknown error occurred', errorCode: 'UNKNOWN_ERROR' };\n  } finally {\n    stopKeepalive();\n  }\n}\n\n/**\n * Handle streaming response from Gemini\n */\nasync function handleStreamingResponse(\n  response: Response,\n  requestModel: string\n): Promise<GeminiResponse> {\n  const reader = response.body?.getReader();\n  if (!reader) {\n    return { success: false, error: 'No response body', errorCode: 'NO_RESPONSE_BODY' };\n  }\n\n  const decoder = new TextDecoder();\n  let content = '';\n  let promptTokens: number | undefined;\n  let completionTokens: number | undefined;\n  let totalTokens: number | undefined;\n  let finishReason: string | undefined;\n\n  try {\n    let buffer = '';\n\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        break;\n      }\n\n      buffer += decoder.decode(value, { stream: true });\n\n      // Gemini uses JSON array streaming format\n      // Each chunk starts with [ and ends with ] or contains ,{...}\n      // We need to parse individual JSON objects from the stream\n\n      // Try to extract complete JSON objects from buffer\n      const extracted = extractJsonObjects(buffer);\n      buffer = extracted.remaining;\n\n      for (const jsonStr of extracted.objects) {\n        try {\n          const chunk = JSON.parse(jsonStr) as GeminiStreamChunk;\n\n          // Extract content\n          const text = chunk.candidates?.[0]?.content?.parts?.[0]?.text;\n          if (text) {\n            content += text;\n          }\n\n          // Extract finish reason\n          const reason = chunk.candidates?.[0]?.finishReason;\n          if (reason) {\n            finishReason = reason;\n          }\n\n          // Extract usage metadata\n          if (chunk.usageMetadata) {\n            promptTokens = chunk.usageMetadata.promptTokenCount;\n            completionTokens = chunk.usageMetadata.candidatesTokenCount;\n            totalTokens = chunk.usageMetadata.totalTokenCount;\n          }\n        } catch (parseError) {\n          log('debug', 'Failed to parse chunk:', jsonStr);\n        }\n      }\n    }\n\n    log('info', `Streaming complete. Received ${content.length} characters`);\n\n    return {\n      success: true,\n      content,\n      promptTokens,\n      completionTokens,\n      totalTokens,\n      model: requestModel,\n      finishReason,\n    };\n  } catch (error) {\n    log('error', 'Streaming error:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Streaming failed',\n      errorCode: 'STREAMING_ERROR',\n    };\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * Extract complete JSON objects from a buffer containing Gemini's streaming response\n * Gemini returns chunks in format: [{...},{...},...] or line-delimited JSON\n */\nfunction extractJsonObjects(buffer: string): { objects: string[]; remaining: string } {\n  const objects: string[] = [];\n  let remaining = buffer;\n\n  // Try to find complete JSON objects\n  // Gemini can return either newline-delimited JSON or array format\n\n  // First, try line-delimited format\n  const lines = remaining.split('\\n');\n  remaining = lines.pop() || ''; // Keep last (possibly incomplete) line\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === '[' || trimmed === ']' || trimmed === ',') {\n      continue;\n    }\n\n    // Remove leading comma and array brackets\n    let jsonStr = trimmed;\n    if (jsonStr.startsWith(',')) {\n      jsonStr = jsonStr.substring(1);\n    }\n    if (jsonStr.startsWith('[')) {\n      jsonStr = jsonStr.substring(1);\n    }\n    if (jsonStr.endsWith(',')) {\n      jsonStr = jsonStr.slice(0, -1);\n    }\n    if (jsonStr.endsWith(']')) {\n      jsonStr = jsonStr.slice(0, -1);\n    }\n\n    jsonStr = jsonStr.trim();\n    if (jsonStr && jsonStr.startsWith('{') && jsonStr.endsWith('}')) {\n      objects.push(jsonStr);\n    }\n  }\n\n  return { objects, remaining };\n}\n\n/**\n * Validate a Gemini API key by making a test request\n *\n * @param apiKey - API key to validate\n * @returns Validation result\n */\nexport async function validateApiKey(apiKey: string): Promise<{\n  valid: boolean;\n  error?: string;\n  models?: string[];\n}> {\n  try {\n    const response = await fetch(\n      `${GEMINI_API_BASE}/models?key=${apiKey}`,\n      { method: 'GET' }\n    );\n\n    if (!response.ok) {\n      if (response.status === 400 || response.status === 401) {\n        return { valid: false, error: 'Invalid API key' };\n      }\n      return { valid: false, error: `HTTP ${response.status}: ${response.statusText}` };\n    }\n\n    const data = await response.json();\n    const models = data.models\n      ?.filter((m: { name: string }) => m.name.includes('gemini'))\n      ?.map((m: { name: string }) => m.name.replace('models/', '')) || [];\n\n    return { valid: true, models };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error instanceof Error ? error.message : 'Validation failed',\n    };\n  }\n}\n\n/**\n * Estimate token count for a string (rough approximation)\n * Gemini uses similar tokenization to GPT models\n *\n * @param text - Text to estimate\n * @returns Estimated token count\n */\nexport function estimateTokens(text: string): number {\n  // For CJK characters, use ~1.5 tokens per character\n  // For other text, use ~4 characters per token\n  const cjkChars = text.match(/[\\u4e00-\\u9fff\\u3400-\\u4dbf\\u3000-\\u303f]/g)?.length || 0;\n  const otherChars = text.length - cjkChars;\n\n  return Math.ceil(cjkChars * 1.5 + otherChars / 4);\n}\n\n/**\n * Convert OpenAI-style messages to Gemini format\n * Useful for unified interface in translator module\n */\nexport function convertFromOpenAIFormat(\n  messages: Array<{ role: string; content: string }>\n): { systemInstruction?: string; contents: GeminiContent[] } {\n  let systemInstruction: string | undefined;\n  const contents: GeminiContent[] = [];\n\n  for (const msg of messages) {\n    if (msg.role === 'system') {\n      // System messages become system instruction\n      systemInstruction = msg.content;\n    } else {\n      // Map user/assistant to user/model\n      const role = msg.role === 'assistant' ? 'model' : 'user';\n      contents.push({\n        role,\n        parts: [{ text: msg.content }],\n      });\n    }\n  }\n\n  return { systemInstruction, contents };\n}\n\n// ============================================\n// Exports\n// ============================================\n\nexport default {\n  generateContent,\n  validateApiKey,\n  estimateTokens,\n  convertFromOpenAIFormat,\n  setLogLevel,\n};\n", "/**\n * LLM Translator Module (Refactored)\n *\n * Translates WebVTT subtitles using LLM APIs (OpenAI / Gemini).\n * New approach: Direct VTT input \u2192 LLM \u2192 Complete VTT output\n *\n * Task ID: T-20251223-act-007-build-llm-translator (Refactored)\n *\n * Features:\n * - Direct VTT file translation (input entire VTT, output translated VTT)\n * - Duration-based batching (10 minutes per batch)\n * - Supports GPT-5.x and Gemini 2.5/3.x models\n * - Course context in prompts\n * - Token usage and cost tracking\n * - Timeout handling and retry mechanism\n */\n\nimport type { VTTFile, VTTCue, CourseInfo } from '../types';\nimport { parseVTT, timestampToMs } from '../utils/webvtt-parser';\nimport { generateVTT, mergeVTTFiles } from '../utils/webvtt-generator';\nimport { calculateCost } from '../utils/cost-estimator';\nimport { chatCompletion, estimateTokens as openaiEstimateTokens } from './openai-client';\nimport { generateContent, convertFromOpenAIFormat, estimateTokens as geminiEstimateTokens } from './gemini-client';\n\n// ============================================\n// Types\n// ============================================\n\n/**\n * Translation request options\n */\nexport interface TranslationOptions {\n  /** LLM provider */\n  provider: 'openai' | 'gemini';\n  /** API key */\n  apiKey: string;\n  /** Model name */\n  model: string;\n  /** Course context for better terminology */\n  courseContext?: CourseContext;\n  /** Request timeout in milliseconds (default: 120000 for longer VTT) */\n  timeout?: number;\n  /** Maximum retry attempts (default: 2) */\n  maxRetries?: number;\n  /** Abort signal for cancellation */\n  signal?: AbortSignal;\n  /** Max duration per batch in milliseconds (default: 600000 = 10 minutes) */\n  maxBatchDurationMs?: number;\n  /** Progress callback (0-100) */\n  onProgress?: (progress: number) => void;\n}\n\n/**\n * Course context for translation\n */\nexport interface CourseContext {\n  /** Course name */\n  courseName?: string;\n  /** Section/chapter name */\n  sectionName?: string;\n  /** Lecture name */\n  lectureName?: string;\n  /** Subject/topic hints */\n  subject?: string;\n}\n\n/**\n * Translation result\n */\nexport interface TranslationResult {\n  /** Whether translation succeeded */\n  success: boolean;\n  /** Translated VTT content as string */\n  translatedVTT?: string;\n  /** Translated VTT as parsed structure */\n  translatedVTTFile?: VTTFile;\n  /** Error message if failed */\n  error?: string;\n  /** Error code */\n  errorCode?: string;\n  /** Tokens used (prompt + completion) */\n  tokensUsed?: number;\n  /** Prompt tokens */\n  promptTokens?: number;\n  /** Completion tokens */\n  completionTokens?: number;\n  /** Estimated cost in USD */\n  estimatedCost?: number;\n  /** Model used */\n  model?: string;\n  /** Number of cues translated */\n  cueCount?: number;\n  /** Number of batches used */\n  batchCount?: number;\n  /** Translation duration in milliseconds */\n  durationMs?: number;\n}\n\n/**\n * Validation result for translated VTT\n */\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\n// ============================================\n// Constants\n// ============================================\n\nconst LOG_PREFIX = '[Translator]';\nconst DEFAULT_TIMEOUT = 120000; // 120 seconds for longer content\nconst DEFAULT_MAX_RETRIES = 2;\nconst DEFAULT_MAX_BATCH_DURATION_MS = 10 * 60 * 1000; // 10 minutes\n\nexport { calculateCost } from '../utils/cost-estimator';\n\n// ============================================\n// Logger\n// ============================================\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nlet currentLogLevel: LogLevel = 'info';\n\nfunction log(level: LogLevel, ...args: unknown[]): void {\n  if (LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel]) {\n    const method = level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log';\n    console[method](LOG_PREFIX, `[${level.toUpperCase()}]`, ...args);\n  }\n}\n\n/**\n * Set the logging level\n */\nexport function setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n// ============================================\n// Prompt Building\n// ============================================\n\n/**\n * Build the system prompt for VTT translation\n * Target: English to Chinese translation\n */\nexport function buildSystemPrompt(courseContext?: CourseContext): string {\n  let prompt = `You are an expert subtitle translator. You will receive a WebVTT subtitle file.\nTranslate all subtitle text from English to Chinese (\u7B80\u4F53\u4E2D\u6587).\n\nCRITICAL RULES - YOU MUST FOLLOW THESE EXACTLY:\n1. Output a COMPLETE, VALID WebVTT file\n2. Start your output with \"WEBVTT\" header\n3. Keep ALL timestamps EXACTLY as they are - do not modify any timestamp\n4. Translate ONLY the text content between timestamps\n5. Preserve cue IDs if present (the line before timestamps)\n6. Preserve all cue settings (text after the --> timestamp)\n7. Do NOT add any explanations, notes, or markdown formatting\n8. Do NOT wrap the output in code blocks\n9. Keep the same number of cues as the input\n\nFor technical terms commonly kept in English (API, HTTP, JavaScript, React, etc.), keep them as-is.\nUse natural, fluent Chinese expressions - avoid word-for-word translation.`;\n\n  // Add course context if available\n  if (courseContext) {\n    const contextParts: string[] = [];\n\n    if (courseContext.courseName) {\n      contextParts.push(`Course: \"${courseContext.courseName}\"`);\n    }\n    if (courseContext.sectionName) {\n      contextParts.push(`Section: \"${courseContext.sectionName}\"`);\n    }\n    if (courseContext.lectureName) {\n      contextParts.push(`Lecture: \"${courseContext.lectureName}\"`);\n    }\n    if (courseContext.subject) {\n      contextParts.push(`Subject: ${courseContext.subject}`);\n    }\n\n    if (contextParts.length > 0) {\n      prompt += `\\n\\nCONTEXT (use this to improve terminology translation):\n${contextParts.join('\\n')}`;\n    }\n  }\n\n  return prompt;\n}\n\n/**\n * Build the user prompt with the VTT content\n */\nexport function buildUserPrompt(vttContent: string): string {\n  return `Translate this WebVTT file to Chinese (\u7B80\u4F53\u4E2D\u6587). Output ONLY the translated WebVTT file, nothing else:\n\n${vttContent}`;\n}\n\n// ============================================\n// VTT Duration-Based Splitting\n// ============================================\n\n/**\n * Split a VTT file into batches based on duration\n *\n * @param vttFile - Parsed VTT file\n * @param maxDurationMs - Maximum duration per batch in milliseconds\n * @returns Array of VTT file batches\n */\nexport function splitVTTByDuration(vttFile: VTTFile, maxDurationMs: number): VTTFile[] {\n  if (vttFile.cues.length === 0) {\n    return [vttFile];\n  }\n\n  const batches: VTTFile[] = [];\n  let currentBatchCues: VTTCue[] = [];\n  let batchStartTime = timestampToMs(vttFile.cues[0].startTime);\n\n  for (const cue of vttFile.cues) {\n    const cueEndMs = timestampToMs(cue.endTime);\n\n    // If adding this cue would exceed max duration, start a new batch\n    if (currentBatchCues.length > 0 && (cueEndMs - batchStartTime) > maxDurationMs) {\n      // Save current batch\n      batches.push({\n        header: vttFile.header,\n        cues: currentBatchCues,\n        // Don't include styles/regions/notes in intermediate batches\n      });\n\n      // Start new batch\n      currentBatchCues = [];\n      batchStartTime = timestampToMs(cue.startTime);\n    }\n\n    currentBatchCues.push(cue);\n  }\n\n  // Add the last batch\n  if (currentBatchCues.length > 0) {\n    batches.push({\n      header: vttFile.header,\n      cues: currentBatchCues,\n      styles: vttFile.styles,\n      regions: vttFile.regions,\n      notes: vttFile.notes,\n    });\n  }\n\n  return batches;\n}\n\n/**\n * Get the duration span of cues in a VTT file\n */\nexport function getVTTDurationSpan(vttFile: VTTFile): { startMs: number; endMs: number; durationMs: number } {\n  if (vttFile.cues.length === 0) {\n    return { startMs: 0, endMs: 0, durationMs: 0 };\n  }\n\n  const startMs = timestampToMs(vttFile.cues[0].startTime);\n  const endMs = timestampToMs(vttFile.cues[vttFile.cues.length - 1].endTime);\n\n  return {\n    startMs,\n    endMs,\n    durationMs: endMs - startMs,\n  };\n}\n\n// ============================================\n// VTT Response Parsing and Validation\n// ============================================\n\n/**\n * Parse the LLM response as a VTT file\n */\nexport function parseTranslatedVTTResponse(response: string): {\n  success: boolean;\n  vttFile?: VTTFile;\n  error?: string;\n} {\n  // Clean up the response\n  let cleanedResponse = response.trim();\n\n  // Remove markdown code blocks if present\n  if (cleanedResponse.startsWith('```')) {\n    cleanedResponse = cleanedResponse\n      .replace(/^```(?:vtt|webvtt)?\\s*\\n?/i, '')\n      .replace(/\\n?```\\s*$/, '');\n  }\n\n  // Ensure WEBVTT header\n  if (!cleanedResponse.startsWith('WEBVTT')) {\n    // Try to find WEBVTT in the response\n    const webvttIndex = cleanedResponse.indexOf('WEBVTT');\n    if (webvttIndex !== -1) {\n      cleanedResponse = cleanedResponse.substring(webvttIndex);\n    } else {\n      return {\n        success: false,\n        error: 'Response does not contain valid WEBVTT header',\n      };\n    }\n  }\n\n  // Parse the VTT content\n  const parseResult = parseVTT(cleanedResponse);\n\n  if (!parseResult.success || !parseResult.data) {\n    return {\n      success: false,\n      error: parseResult.error || 'Failed to parse VTT response',\n    };\n  }\n\n  return {\n    success: true,\n    vttFile: parseResult.data,\n  };\n}\n\n/**\n * Validate that the translated VTT matches the original structure\n */\nexport function validateTranslatedVTT(original: VTTFile, translated: VTTFile): ValidationResult {\n  const errors: string[] = [];\n\n  // 1. Check cue count\n  if (original.cues.length !== translated.cues.length) {\n    errors.push(`Cue count mismatch: expected ${original.cues.length}, got ${translated.cues.length}`);\n  }\n\n  // 2. Check timestamps match\n  const checkCount = Math.min(original.cues.length, translated.cues.length);\n  for (let i = 0; i < checkCount; i++) {\n    const origCue = original.cues[i];\n    const transCue = translated.cues[i];\n\n    const origStartMs = timestampToMs(origCue.startTime);\n    const origEndMs = timestampToMs(origCue.endTime);\n    const transStartMs = timestampToMs(transCue.startTime);\n    const transEndMs = timestampToMs(transCue.endTime);\n\n    if (origStartMs !== transStartMs || origEndMs !== transEndMs) {\n      errors.push(`Timestamp mismatch at cue ${i + 1}: expected ${origStartMs}-${origEndMs}, got ${transStartMs}-${transEndMs}`);\n      // Only report first few timestamp errors\n      if (errors.length >= 5) {\n        errors.push('(more timestamp errors omitted)');\n        break;\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n// ============================================\n// Main Translation Functions\n// ============================================\n\n/**\n * Translate VTT content using LLM (new direct VTT approach)\n *\n * @param vttContent - Raw VTT content string\n * @param options - Translation options\n * @returns Translation result\n */\nexport async function translateVTT(\n  vttContent: string,\n  options: TranslationOptions\n): Promise<TranslationResult> {\n  const startTime = Date.now();\n\n  const {\n    provider,\n    apiKey,\n    model,\n    courseContext,\n    timeout = DEFAULT_TIMEOUT,\n    maxRetries = DEFAULT_MAX_RETRIES,\n    maxBatchDurationMs = DEFAULT_MAX_BATCH_DURATION_MS,\n    signal,\n    onProgress,\n  } = options;\n\n  const reportProgress = (progress: number): void => {\n    if (!onProgress) return;\n    try {\n      onProgress(progress);\n    } catch (e) {\n      log('warn', 'onProgress callback error:', e);\n    }\n  };\n\n  // Parse VTT content\n  const parseResult = parseVTT(vttContent);\n  if (!parseResult.success || !parseResult.data) {\n    return {\n      success: false,\n      error: parseResult.error || 'Failed to parse VTT content',\n      errorCode: 'PARSE_ERROR',\n    };\n  }\n\n  const vttFile = parseResult.data;\n  const cueCount = vttFile.cues.length;\n\n  if (cueCount === 0) {\n    return {\n      success: false,\n      error: 'No subtitle cues found in VTT content',\n      errorCode: 'EMPTY_CONTENT',\n    };\n  }\n\n  // Split into batches by duration\n  const batches = splitVTTByDuration(vttFile, maxBatchDurationMs);\n  const batchCount = batches.length;\n\n  log('info', `Translating ${cueCount} cues in ${batchCount} batch(es) using ${provider}/${model}`);\n  reportProgress(0);\n\n  // Translate each batch\n  const translatedBatches: VTTFile[] = [];\n  let totalPromptTokens = 0;\n  let totalCompletionTokens = 0;\n\n  const systemPrompt = buildSystemPrompt(courseContext);\n\n  for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {\n    // Check for cancellation\n    if (signal?.aborted) {\n      return {\n        success: false,\n        error: 'Translation cancelled',\n        errorCode: 'CANCELLED',\n      };\n    }\n\n    const batch = batches[batchIndex];\n    const batchVttContent = generateVTT(batch);\n    const duration = getVTTDurationSpan(batch);\n\n    log('info', `Processing batch ${batchIndex + 1}/${batchCount} (${batch.cues.length} cues, ${Math.round(duration.durationMs / 1000)}s)`);\n\n    // Translate batch with retry\n    const result = await translateBatchWithRetry(\n      batch,\n      batchVttContent,\n      systemPrompt,\n      provider,\n      apiKey,\n      model,\n      timeout,\n      maxRetries,\n      signal\n    );\n\n    if (!result.success || !result.vttFile) {\n      return {\n        success: false,\n        error: result.error || `Batch ${batchIndex + 1} translation failed`,\n        errorCode: result.errorCode || 'BATCH_FAILED',\n        durationMs: Date.now() - startTime,\n      };\n    }\n\n    translatedBatches.push(result.vttFile);\n    totalPromptTokens += result.promptTokens || 0;\n    totalCompletionTokens += result.completionTokens || 0;\n\n    const progress = Math.round(((batchIndex + 1) / batchCount) * 100);\n    reportProgress(progress);\n  }\n\n  // Merge all translated batches\n  const mergedVTT = mergeVTTFiles(translatedBatches);\n  const translatedVTTContent = generateVTT(mergedVTT);\n\n  // Calculate cost\n  const tokensUsed = totalPromptTokens + totalCompletionTokens;\n  const cost = calculateCost(model, tokensUsed);\n  const durationMs = Date.now() - startTime;\n\n  log('info', `Translation complete in ${durationMs}ms, ${tokensUsed} tokens, $${cost.toFixed(6)}`);\n  reportProgress(100);\n\n  return {\n    success: true,\n    translatedVTT: translatedVTTContent,\n    translatedVTTFile: mergedVTT,\n    tokensUsed,\n    promptTokens: totalPromptTokens,\n    completionTokens: totalCompletionTokens,\n    estimatedCost: cost,\n    model,\n    cueCount,\n    batchCount,\n    durationMs,\n  };\n}\n\n/**\n * Translate a single batch with retry logic\n */\nasync function translateBatchWithRetry(\n  originalBatch: VTTFile,\n  batchVttContent: string,\n  systemPrompt: string,\n  provider: 'openai' | 'gemini',\n  apiKey: string,\n  model: string,\n  timeout: number,\n  maxRetries: number,\n  signal?: AbortSignal\n): Promise<{\n  success: boolean;\n  vttFile?: VTTFile;\n  error?: string;\n  errorCode?: string;\n  promptTokens?: number;\n  completionTokens?: number;\n}> {\n  const userPrompt = buildUserPrompt(batchVttContent);\n\n  let lastError: string | undefined;\n  let lastErrorCode: string | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    if (attempt > 0) {\n      log('info', `Retry attempt ${attempt}/${maxRetries}`);\n      // Wait before retry (exponential backoff)\n      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt - 1)));\n    }\n\n    // Check for cancellation\n    if (signal?.aborted) {\n      return { success: false, error: 'Translation cancelled', errorCode: 'CANCELLED' };\n    }\n\n    // Call LLM\n    const response = await callLLM(\n      provider,\n      apiKey,\n      model,\n      systemPrompt,\n      userPrompt,\n      timeout,\n      signal\n    );\n\n    if (!response.success || !response.content) {\n      lastError = response.error;\n      lastErrorCode = response.errorCode;\n\n      // Don't retry on auth errors\n      if (response.errorCode === 'INVALID_API_KEY' || response.errorCode === 'MISSING_API_KEY') {\n        break;\n      }\n      continue;\n    }\n\n    // Parse the response as VTT\n    const parseResult = parseTranslatedVTTResponse(response.content);\n\n    if (!parseResult.success || !parseResult.vttFile) {\n      lastError = parseResult.error || 'Failed to parse LLM response as VTT';\n      lastErrorCode = 'PARSE_RESPONSE_ERROR';\n      log('warn', `Parse error: ${lastError}`);\n      continue;\n    }\n\n    // Validate the translated VTT\n    const validation = validateTranslatedVTT(originalBatch, parseResult.vttFile);\n\n    if (!validation.valid) {\n      lastError = `Validation failed: ${validation.errors.join('; ')}`;\n      lastErrorCode = 'VALIDATION_ERROR';\n      log('warn', `Validation error: ${lastError}`);\n\n      // If cue count matches but timestamps differ, we might be able to fix it\n      // For now, just retry\n      continue;\n    }\n\n    // Success!\n    return {\n      success: true,\n      vttFile: parseResult.vttFile,\n      promptTokens: response.promptTokens,\n      completionTokens: response.completionTokens,\n    };\n  }\n\n  return {\n    success: false,\n    error: lastError || 'Translation failed after retries',\n    errorCode: lastErrorCode || 'TRANSLATION_FAILED',\n  };\n}\n\n/**\n * Call LLM API (OpenAI or Gemini)\n * Simple: just send messages and get response, like a ChatGPT conversation\n */\nasync function callLLM(\n  provider: 'openai' | 'gemini',\n  apiKey: string,\n  model: string,\n  systemPrompt: string,\n  userPrompt: string,\n  timeout: number,\n  signal?: AbortSignal\n): Promise<{\n  success: boolean;\n  content?: string;\n  error?: string;\n  errorCode?: string;\n  promptTokens?: number;\n  completionTokens?: number;\n  totalTokens?: number;\n  model?: string;\n}> {\n  if (provider === 'openai') {\n    return chatCompletion({\n      apiKey,\n      model,\n      messages: [\n        { role: 'system', content: systemPrompt },\n        { role: 'user', content: userPrompt },\n      ],\n      timeout,\n      signal,\n    });\n  } else {\n    // Gemini\n    const { systemInstruction, contents } = convertFromOpenAIFormat([\n      { role: 'system', content: systemPrompt },\n      { role: 'user', content: userPrompt },\n    ]);\n\n    return generateContent({\n      apiKey,\n      model,\n      systemInstruction,\n      contents,\n      timeout,\n      signal,\n    });\n  }\n}\n\n// ============================================\n// Utility Functions\n// ============================================\n\n/**\n * Estimate token count for text\n */\nexport function estimateTokens(provider: 'openai' | 'gemini', text: string): number {\n  if (provider === 'openai') {\n    return openaiEstimateTokens(text);\n  } else {\n    return geminiEstimateTokens(text);\n  }\n}\n\n/**\n * Estimate translation cost before running\n */\nexport function estimateTranslationCost(\n  vttContent: string,\n  provider: 'openai' | 'gemini',\n  model: string\n): {\n  cueCount: number;\n  estimatedPromptTokens: number;\n  estimatedOutputTokens: number;\n  estimatedTotalTokens: number;\n  estimatedCost: number;\n  estimatedBatches: number;\n} {\n  const parseResult = parseVTT(vttContent);\n  if (!parseResult.success || !parseResult.data) {\n    return {\n      cueCount: 0,\n      estimatedPromptTokens: 0,\n      estimatedOutputTokens: 0,\n      estimatedTotalTokens: 0,\n      estimatedCost: 0,\n      estimatedBatches: 0,\n    };\n  }\n\n  const cueCount = parseResult.data.cues.length;\n  const batches = splitVTTByDuration(parseResult.data, DEFAULT_MAX_BATCH_DURATION_MS);\n\n  // Estimate tokens per batch\n  const systemPrompt = buildSystemPrompt();\n  let totalPromptTokens = 0;\n\n  for (const batch of batches) {\n    const batchVtt = generateVTT(batch);\n    const userPrompt = buildUserPrompt(batchVtt);\n    totalPromptTokens += estimateTokens(provider, systemPrompt + userPrompt);\n  }\n\n  // Output is roughly similar size to input for VTT translation\n  const estimatedOutputTokens = Math.ceil(totalPromptTokens * 1.2);\n  const estimatedTotalTokens = totalPromptTokens + estimatedOutputTokens;\n  const estimatedCost = calculateCost(model, estimatedTotalTokens);\n\n  return {\n    cueCount,\n    estimatedPromptTokens: totalPromptTokens,\n    estimatedOutputTokens,\n    estimatedTotalTokens,\n    estimatedCost,\n    estimatedBatches: batches.length,\n  };\n}\n\n/**\n * Create a CourseContext from CourseInfo\n */\nexport function createCourseContext(courseInfo: CourseInfo): CourseContext {\n  return {\n    courseName: courseInfo.courseTitle,\n    sectionName: courseInfo.sectionTitle,\n    lectureName: courseInfo.lectureTitle,\n  };\n}\n\n// ============================================\n// Translator Class (OOP Interface)\n// ============================================\n\n/**\n * Translator class for object-oriented usage\n */\nexport class Translator {\n  private options: Partial<TranslationOptions>;\n\n  constructor(options: Partial<TranslationOptions> = {}) {\n    this.options = options;\n  }\n\n  /**\n   * Configure the translator\n   */\n  configure(options: Partial<TranslationOptions>): void {\n    this.options = { ...this.options, ...options };\n  }\n\n  /**\n   * Translate VTT content\n   */\n  async translate(\n    vttContent: string,\n    overrideOptions?: Partial<TranslationOptions>\n  ): Promise<TranslationResult> {\n    const mergedOptions = { ...this.options, ...overrideOptions } as TranslationOptions;\n\n    if (!mergedOptions.provider) {\n      return { success: false, error: 'Provider is required', errorCode: 'MISSING_PROVIDER' };\n    }\n    if (!mergedOptions.apiKey) {\n      return { success: false, error: 'API key is required', errorCode: 'MISSING_API_KEY' };\n    }\n    if (!mergedOptions.model) {\n      return { success: false, error: 'Model is required', errorCode: 'MISSING_MODEL' };\n    }\n\n    return translateVTT(vttContent, mergedOptions);\n  }\n\n  /**\n   * Estimate cost for translation\n   */\n  estimateCost(vttContent: string): ReturnType<typeof estimateTranslationCost> {\n    const provider = this.options.provider || 'openai';\n    const model = this.options.model || 'gpt-5.1';\n    return estimateTranslationCost(vttContent, provider, model);\n  }\n\n  /**\n   * Set course context\n   */\n  setCourseContext(context: CourseContext): void {\n    this.options.courseContext = context;\n  }\n}\n\n// ============================================\n// Export singleton and default\n// ============================================\n\nexport const translator = new Translator();\n\nexport default {\n  translateVTT,\n  estimateTranslationCost,\n  estimateTokens,\n  calculateCost,\n  buildSystemPrompt,\n  buildUserPrompt,\n  splitVTTByDuration,\n  parseTranslatedVTTResponse,\n  validateTranslatedVTT,\n  createCourseContext,\n  Translator,\n  translator,\n  setLogLevel,\n};\n", "/**\n * Preloader - Background subtitle preloading for next lecture\n *\n * Task ID: T-20251223-act-011-build-preload\n *\n * Responsibilities:\n * - Fetch next lecture subtitle (WebVTT) in the background\n * - Translate silently via existing LLM translator\n * - Store translation into IndexedDB cache\n * - Support cancellation via AbortSignal\n */\n\nimport { loadSettings, isEnabled } from '../storage/settings-manager';\nimport { subtitleCache } from '../storage/subtitle-cache';\nimport { addSessionCost, updateSessionCostState } from '../storage/session-cost';\nimport { checkSubtitleVersion } from './version-checker';\nimport { translateVTT } from './translator';\n\nexport interface PreloadRequest {\n  courseId: string;\n  lectureId: string;\n  courseName?: string;\n  sectionName?: string;\n  lectureName?: string;\n  signal?: AbortSignal;\n}\n\nexport interface PreloadResult {\n  ok: boolean;\n  status: 'disabled' | 'cached' | 'translated' | 'aborted' | 'error';\n  courseId: string;\n  lectureId: string;\n  originalHash?: string;\n  provider?: 'openai' | 'gemini';\n  model?: string;\n  error?: string;\n}\n\ntype CaptionTrack = {\n  url: string;\n  language: string;\n  label?: string;\n};\n\nconst LOG_PREFIX = '[UdemyCaptionPlus][Preloader]';\nconst LANGUAGE_PRIORITY = ['en', 'en-US', 'en-GB', 'en-AU'];\n\nfunction log(...args: unknown[]): void {\n  // eslint-disable-next-line no-console\n  console.log(LOG_PREFIX, ...args);\n}\n\nfunction warn(...args: unknown[]): void {\n  // eslint-disable-next-line no-console\n  console.warn(LOG_PREFIX, ...args);\n}\n\nfunction isAbortError(error: unknown): boolean {\n  return error instanceof DOMException && error.name === 'AbortError';\n}\n\nfunction isNumericId(value: string): boolean {\n  return /^\\d+$/.test(value);\n}\n\nfunction normalizeLocale(locale: string): string {\n  const normalized = locale.trim().replace(/_/g, '-');\n  const [language, region, ...rest] = normalized.split('-').filter(Boolean);\n  if (!language) return normalized;\n  if (!region) return language.toLowerCase();\n  const suffix = rest.length > 0 ? `-${rest.join('-')}` : '';\n  return `${language.toLowerCase()}-${region.toUpperCase()}${suffix}`;\n}\n\nfunction inferLanguageFromUrl(url: string): string {\n  const match =\n    url.match(/[_-]([a-z]{2}(?:-[A-Z]{2})?)[_.]/) ||\n    url.match(/lang[=_]([a-z]{2}(?:-[A-Z]{2})?)/i) ||\n    url.match(/locale[=_]([a-z]{2}(?:[_-][A-Z]{2})?)/i);\n  if (!match?.[1]) return 'en';\n  return normalizeLocale(match[1]);\n}\n\nfunction asAbsoluteUrl(url: string): string {\n  try {\n    return new URL(url).toString();\n  } catch {\n    return new URL(url, 'https://www.udemy.com').toString();\n  }\n}\n\nfunction dedupeTracks(tracks: CaptionTrack[]): CaptionTrack[] {\n  const seen = new Set<string>();\n  const result: CaptionTrack[] = [];\n  for (const track of tracks) {\n    if (!track.url) continue;\n    const url = asAbsoluteUrl(track.url);\n    if (seen.has(url)) continue;\n    seen.add(url);\n    result.push({ ...track, url });\n  }\n  return result;\n}\n\nfunction pickPreferredTrack(tracks: CaptionTrack[]): CaptionTrack | null {\n  if (tracks.length === 0) return null;\n\n  for (const lang of LANGUAGE_PRIORITY) {\n    const hit = tracks.find((t) => t.language.toLowerCase() === lang.toLowerCase());\n    if (hit) return hit;\n  }\n\n  const english = tracks.find((t) => t.language.toLowerCase().startsWith('en'));\n  if (english) return english;\n\n  return tracks[0] || null;\n}\n\nfunction toStringIfPresent(value: unknown): string | null {\n  if (typeof value === 'string' && value.trim() !== '') return value.trim();\n  if (typeof value === 'number' && Number.isFinite(value)) return String(value);\n  return null;\n}\n\nfunction extractTracksFromCaptionArray(captions: unknown[]): CaptionTrack[] {\n  const tracks: CaptionTrack[] = [];\n\n  for (const item of captions) {\n    if (!item || typeof item !== 'object') continue;\n    const obj = item as Record<string, unknown>;\n\n    const url =\n      toStringIfPresent(obj.url) ||\n      toStringIfPresent(obj.download_url) ||\n      toStringIfPresent(obj.downloadUrl) ||\n      toStringIfPresent(obj.vtt_url) ||\n      toStringIfPresent(obj.vttUrl) ||\n      toStringIfPresent(obj.file) ||\n      null;\n\n    if (!url || !url.includes('.vtt')) continue;\n\n    const languageRaw =\n      toStringIfPresent(obj.language) ||\n      toStringIfPresent(obj.locale) ||\n      toStringIfPresent(obj.srclang) ||\n      toStringIfPresent(obj.language_code) ||\n      toStringIfPresent(obj.lang) ||\n      null;\n\n    const language = languageRaw ? normalizeLocale(languageRaw) : inferLanguageFromUrl(url);\n    const label = toStringIfPresent(obj.label) || language;\n\n    tracks.push({ url, language, label });\n  }\n\n  return tracks;\n}\n\nfunction collectVttUrlsRecursively(data: unknown, maxNodes: number = 2000): CaptionTrack[] {\n  const tracks: CaptionTrack[] = [];\n  const visited = new Set<unknown>();\n  const queue: unknown[] = [data];\n  let visitedCount = 0;\n\n  while (queue.length > 0 && visitedCount < maxNodes) {\n    const node = queue.shift();\n    if (!node || typeof node !== 'object') continue;\n    if (visited.has(node)) continue;\n    visited.add(node);\n    visitedCount++;\n\n    if (Array.isArray(node)) {\n      for (const item of node) queue.push(item);\n      continue;\n    }\n\n    const obj = node as Record<string, unknown>;\n    const keys = Object.keys(obj);\n    for (const key of keys) {\n      const value = obj[key];\n      if (typeof value === 'string' && value.includes('.vtt')) {\n        const languageRaw =\n          toStringIfPresent(obj.language) ||\n          toStringIfPresent(obj.locale) ||\n          toStringIfPresent(obj.srclang) ||\n          toStringIfPresent(obj.language_code) ||\n          toStringIfPresent(obj.lang) ||\n          null;\n        const language = languageRaw ? normalizeLocale(languageRaw) : inferLanguageFromUrl(value);\n        tracks.push({ url: value, language, label: language });\n      } else if (value && typeof value === 'object') {\n        queue.push(value);\n      }\n    }\n  }\n\n  return tracks;\n}\n\nfunction extractCaptionTracks(data: unknown): CaptionTrack[] {\n  const tracks: CaptionTrack[] = [];\n  const root = data as any;\n\n  const arrays: unknown[][] = [];\n  if (Array.isArray(root?.asset?.captions)) arrays.push(root.asset.captions);\n  if (Array.isArray(root?.asset?.caption_tracks)) arrays.push(root.asset.caption_tracks);\n  if (Array.isArray(root?.captions)) arrays.push(root.captions);\n  if (Array.isArray(root?.results)) arrays.push(root.results);\n\n  for (const arr of arrays) tracks.push(...extractTracksFromCaptionArray(arr));\n  tracks.push(...collectVttUrlsRecursively(data));\n\n  return dedupeTracks(tracks);\n}\n\nasync function fetchJson(url: string, signal?: AbortSignal): Promise<unknown> {\n  const response = await fetch(url, { credentials: 'include', signal });\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status} for ${url}`);\n  }\n  return response.json();\n}\n\nasync function resolveNumericCourseId(courseId: string, signal?: AbortSignal): Promise<string | null> {\n  if (isNumericId(courseId)) return courseId;\n  try {\n    const url = `https://www.udemy.com/api-2.0/courses/${encodeURIComponent(courseId)}/?fields[course]=id`;\n    const data = (await fetchJson(url, signal)) as { id?: number | string } | null;\n    const id = toStringIfPresent(data?.id);\n    if (id && isNumericId(id)) return id;\n  } catch {\n    // ignore\n  }\n  return null;\n}\n\nasync function fetchLectureCaptionTracks(\n  courseId: string,\n  lectureId: string,\n  signal?: AbortSignal\n): Promise<{ lectureTitle?: string; tracks: CaptionTrack[] }> {\n  const numericCourseId = await resolveNumericCourseId(courseId, signal);\n\n  const attempts: Array<() => Promise<{ lectureTitle?: string; tracks: CaptionTrack[] }>> = [];\n\n  if (numericCourseId) {\n    attempts.push(async () => {\n      const url =\n        `https://www.udemy.com/api-2.0/users/me/subscribed-courses/${numericCourseId}/lectures/${lectureId}/` +\n        `?fields[lecture]=title,asset&fields[asset]=captions`;\n      const data = (await fetchJson(url, signal)) as any;\n      const tracks = extractCaptionTracks(data);\n      return { lectureTitle: typeof data?.title === 'string' ? data.title : undefined, tracks };\n    });\n  }\n\n  attempts.push(async () => {\n    const url =\n      `https://www.udemy.com/api-2.0/lectures/${lectureId}/` +\n      `?fields[lecture]=title,asset&fields[asset]=captions`;\n    const data = (await fetchJson(url, signal)) as any;\n    const tracks = extractCaptionTracks(data);\n    return { lectureTitle: typeof data?.title === 'string' ? data.title : undefined, tracks };\n  });\n\n  attempts.push(async () => {\n    const url = `https://www.udemy.com/api-2.0/lectures/${lectureId}/captions/`;\n    const data = (await fetchJson(url, signal)) as any;\n    const tracks = extractCaptionTracks(data);\n    return { lectureTitle: undefined, tracks };\n  });\n\n  if (numericCourseId) {\n    attempts.push(async () => {\n      const url =\n        `https://www.udemy.com/api-2.0/courses/${numericCourseId}/subscriber-curriculum-items/` +\n        `?page_size=1400&fields[lecture]=title,asset&fields[asset]=captions&caching_intent=True`;\n      const data = (await fetchJson(url, signal)) as any;\n      const results = Array.isArray(data?.results) ? data.results : [];\n      const lecture = results.find((item: any) => item && item._class === 'lecture' && String(item.id) === lectureId);\n      const tracks = extractCaptionTracks(lecture);\n      return { lectureTitle: typeof lecture?.title === 'string' ? lecture.title : undefined, tracks };\n    });\n  }\n\n  let lastError: unknown = null;\n  for (const attempt of attempts) {\n    try {\n      const result = await attempt();\n      if (result.tracks.length > 0) return result;\n      lastError = new Error('No caption tracks found');\n    } catch (error) {\n      lastError = error;\n    }\n  }\n\n  throw lastError instanceof Error ? lastError : new Error(String(lastError));\n}\n\nasync function fetchVtt(url: string, signal?: AbortSignal): Promise<string> {\n  const resolved = asAbsoluteUrl(url);\n  const response = await fetch(resolved, { credentials: 'include', signal });\n  if (!response.ok) {\n    throw new Error(`Failed to fetch VTT (${response.status})`);\n  }\n  return response.text();\n}\n\n/**\n * Preload + translate a lecture's subtitle into cache.\n */\nexport async function preloadLecture(request: PreloadRequest): Promise<PreloadResult> {\n  const { courseId, lectureId, signal } = request;\n\n  try {\n    const settings = await loadSettings();\n    if (!isEnabled(settings) || !settings.preloadEnabled) {\n      return { ok: true, status: 'disabled', courseId, lectureId };\n    }\n\n    const { lectureTitle, tracks } = await fetchLectureCaptionTracks(courseId, lectureId, signal);\n    const selected = pickPreferredTrack(tracks);\n    if (!selected) {\n      return {\n        ok: false,\n        status: 'error',\n        courseId,\n        lectureId,\n        error: 'No subtitle tracks available for preload',\n      };\n    }\n\n    const originalVtt = await fetchVtt(selected.url, signal);\n    if (!originalVtt.trim().startsWith('WEBVTT')) {\n      return {\n        ok: false,\n        status: 'error',\n        courseId,\n        lectureId,\n        error: 'Fetched subtitle is not a valid WebVTT file',\n      };\n    }\n\n    const version = await checkSubtitleVersion({\n      courseId,\n      lectureId,\n      originalVtt,\n      force: false,\n    });\n\n    if (version.decision === 'use_cache') {\n      log('Cache valid, skip preload:', `${courseId}-${lectureId}`);\n      return {\n        ok: true,\n        status: 'cached',\n        courseId,\n        lectureId,\n        originalHash: version.originalHash,\n      };\n    }\n\n    log('Preloading translation:', `${courseId}-${lectureId}`);\n\n    const result = await translateVTT(originalVtt, {\n      provider: settings.provider,\n      apiKey: settings.apiKey,\n      model: settings.model,\n      courseContext: {\n        courseName: request.courseName,\n        sectionName: request.sectionName,\n        lectureName: request.lectureName || lectureTitle,\n      },\n      signal,\n    });\n\n    const actualTokens = typeof result.tokensUsed === 'number' ? result.tokensUsed : 0;\n    const actualCostUsd = typeof result.estimatedCost === 'number' ? result.estimatedCost : 0;\n    const now = Date.now();\n    const taskId = `preload-${courseId}-${lectureId}-${now}`;\n\n    if (!result.success || !result.translatedVTT) {\n      if (actualTokens > 0 || actualCostUsd > 0) {\n        await addSessionCost(actualTokens, actualCostUsd);\n        await updateSessionCostState({\n          lastActual: {\n            taskId,\n            provider: settings.provider,\n            model: settings.model,\n            tokensUsed: actualTokens,\n            costUsd: actualCostUsd,\n            createdAt: now,\n          },\n        });\n      }\n\n      return {\n        ok: false,\n        status: 'error',\n        courseId,\n        lectureId,\n        originalHash: version.originalHash,\n        provider: settings.provider,\n        model: settings.model,\n        error: result.error || 'Translation failed',\n      };\n    }\n\n    if (actualTokens > 0 || actualCostUsd > 0) {\n      await addSessionCost(actualTokens, actualCostUsd);\n      await updateSessionCostState({\n        lastActual: {\n          taskId,\n          provider: settings.provider,\n          model: settings.model,\n          tokensUsed: actualTokens,\n          costUsd: actualCostUsd,\n          createdAt: now,\n        },\n      });\n    }\n\n    await subtitleCache.set({\n      courseId,\n      lectureId,\n      courseName: request.courseName || '',\n      lectureName: request.lectureName || lectureTitle || lectureId,\n      originalHash: version.originalHash,\n      translatedVTT: result.translatedVTT,\n      provider: settings.provider,\n      model: settings.model,\n      tokensUsed: actualTokens,\n      estimatedCost: actualCostUsd,\n    });\n\n    return {\n      ok: true,\n      status: 'translated',\n      courseId,\n      lectureId,\n      originalHash: version.originalHash,\n      provider: settings.provider,\n      model: settings.model,\n    };\n  } catch (error) {\n    if (signal?.aborted || isAbortError(error)) {\n      warn('Preload aborted:', `${courseId}-${lectureId}`);\n      return { ok: true, status: 'aborted', courseId, lectureId };\n    }\n    warn('Preload failed:', error);\n    return { ok: false, status: 'error', courseId, lectureId, error: String(error) };\n  }\n}\n", "/**\n * Service Worker Entrypoint (Manifest V3)\n *\n * Focus for Task ID: T-20251223-act-012-build-retranslate\n * - Check cached subtitle version by originalHash\n * - Force retranslation when requested\n * - Send progress + completion updates (for Popup UI)\n */\n\nimport { loadSettings, isEnabled } from '../storage/settings-manager';\nimport { subtitleCache } from '../storage/subtitle-cache';\nimport { addSessionCost, updateSessionCostState } from '../storage/session-cost';\nimport { checkSubtitleVersion } from '../services/version-checker';\nimport { estimateTranslationCost, translateVTT } from '../services/translator';\nimport { preloadLecture } from '../services/preloader';\nimport { calculateHash } from '../utils/hash';\n\ntype AnyMessage = { type: string; payload?: any; meta?: any };\n\nconst activeControllers = new Map<string, AbortController>();\nconst activePreloadByTab = new Map<\n  number,\n  { controller: AbortController; courseId: string; lectureId: string }\n>();\n\nfunction sendToTab(tabId: number, message: AnyMessage): void {\n  if (typeof chrome === 'undefined' || !chrome.tabs?.sendMessage) return;\n  chrome.tabs.sendMessage(tabId, message).catch(() => {});\n}\n\nfunction sendToPopup(message: AnyMessage): void {\n  if (typeof chrome === 'undefined' || !chrome.runtime?.sendMessage) return;\n  chrome.runtime.sendMessage({ ...message, meta: { ...(message.meta || {}), target: 'popup' } }).catch(() => {});\n}\n\nfunction sendProgress(tabId: number, taskId: string, progress: number): void {\n  const payload = { taskId, progress };\n  sendToTab(tabId, { type: 'TRANSLATION_PROGRESS', payload, meta: { target: 'content' } });\n  sendToPopup({ type: 'TRANSLATION_PROGRESS', payload });\n}\n\nfunction sendCostEstimate(tabId: number, payload: any): void {\n  sendToTab(tabId, { type: 'COST_ESTIMATE', payload, meta: { target: 'content' } });\n  sendToPopup({ type: 'COST_ESTIMATE', payload });\n}\n\nfunction sendComplete(tabId: number, payload: any): void {\n  sendToTab(tabId, { type: 'TRANSLATION_COMPLETE', payload, meta: { target: 'content' } });\n  sendToPopup({ type: 'TRANSLATION_COMPLETE', payload });\n}\n\nasync function handleTranslateSubtitle(sender: chrome.runtime.MessageSender, payload: any): Promise<void> {\n  const tabId = sender.tab?.id;\n  if (!tabId) {\n    return;\n  }\n\n  const taskId: string = payload?.taskId || `translate-${Date.now()}`;\n  const vttContent: string | undefined = payload?.vttContent;\n  const courseId: string | undefined = payload?.courseId;\n  const lectureId: string | undefined = payload?.lectureId;\n  const force: boolean = payload?.force === true;\n\n  if (!vttContent || !courseId || !lectureId) {\n    sendComplete(tabId, { taskId, success: false, error: 'Missing required fields' });\n    return;\n  }\n\n  const settings = await loadSettings();\n  if (!isEnabled(settings)) {\n    sendComplete(tabId, { taskId, success: false, error: 'Translation is disabled or not configured' });\n    return;\n  }\n\n  const provider = payload?.provider || settings.provider;\n  const model = payload?.model || settings.model;\n  const apiKey = settings.apiKey;\n\n  const originalHash: string = payload?.originalHash || (await calculateHash(vttContent));\n\n  const version = await checkSubtitleVersion({\n    courseId,\n    lectureId,\n    originalHash,\n    force,\n  });\n\n  if (version.decision === 'use_cache' && version.cachedEntry?.translatedVTT) {\n    sendToTab(tabId, {\n      type: 'CACHE_HIT',\n      payload: { taskId, translatedVTT: version.cachedEntry.translatedVTT },\n      meta: { target: 'content' },\n    });\n    // Popup UI: best-effort notification (no auto-hide here; Popup decides)\n    sendToPopup({\n      type: 'CACHE_HIT',\n      payload: {\n        taskId,\n        provider: version.cachedEntry.provider,\n        model: version.cachedEntry.model,\n        tokensUsed: version.cachedEntry.tokensUsed,\n        costUsd: version.cachedEntry.estimatedCost,\n        fromCache: true,\n      },\n    });\n    return;\n  }\n\n  // Cancel any existing task with the same id\n  const existing = activeControllers.get(taskId);\n  if (existing) {\n    existing.abort();\n    activeControllers.delete(taskId);\n  }\n\n  const controller = new AbortController();\n  activeControllers.set(taskId, controller);\n\n  if (settings.showCostEstimate) {\n    const estimate = estimateTranslationCost(vttContent, provider, model);\n    const estimatePayload = {\n      taskId,\n      provider,\n      model,\n      cueCount: estimate.cueCount,\n      estimatedPromptTokens: estimate.estimatedPromptTokens,\n      estimatedOutputTokens: estimate.estimatedOutputTokens,\n      estimatedTotalTokens: estimate.estimatedTotalTokens,\n      estimatedCostUsd: estimate.estimatedCost,\n      estimatedBatches: estimate.estimatedBatches,\n    };\n\n    sendCostEstimate(tabId, estimatePayload);\n    await updateSessionCostState({\n      lastEstimate: {\n        taskId,\n        provider,\n        model,\n        cueCount: estimate.cueCount,\n        estimatedTotalTokens: estimate.estimatedTotalTokens,\n        estimatedCostUsd: estimate.estimatedCost,\n        createdAt: Date.now(),\n      },\n    });\n  }\n\n  sendProgress(tabId, taskId, 0);\n\n  const result = await translateVTT(vttContent, {\n    provider,\n    apiKey,\n    model,\n    courseContext: {\n      courseName: payload?.courseName,\n      sectionName: payload?.sectionName,\n      lectureName: payload?.lectureName,\n    },\n    signal: controller.signal,\n    onProgress: (progress) => sendProgress(tabId, taskId, progress),\n  });\n\n  activeControllers.delete(taskId);\n\n  const actualTokens = typeof result.tokensUsed === 'number' ? result.tokensUsed : 0;\n  const actualCostUsd = typeof result.estimatedCost === 'number' ? result.estimatedCost : 0;\n\n  if (result.success && result.translatedVTT) {\n    const sessionState = await addSessionCost(actualTokens, actualCostUsd);\n    await updateSessionCostState({\n      lastActual: {\n        taskId,\n        provider,\n        model,\n        tokensUsed: actualTokens,\n        costUsd: actualCostUsd,\n        createdAt: Date.now(),\n      },\n    });\n\n    await subtitleCache.set({\n      courseId,\n      lectureId,\n      courseName: payload?.courseName || '',\n      lectureName: payload?.lectureName || payload?.lectureId || '',\n      originalHash,\n      translatedVTT: result.translatedVTT,\n      provider,\n      model,\n      tokensUsed: actualTokens,\n      estimatedCost: actualCostUsd,\n    });\n\n    sendComplete(tabId, {\n      taskId,\n      success: true,\n      translatedVTT: result.translatedVTT,\n      provider,\n      model,\n      tokensUsed: actualTokens,\n      estimatedCost: actualCostUsd,\n      sessionTotalTokens: sessionState.totals.totalTokens,\n      sessionTotalCostUsd: sessionState.totals.totalCostUsd,\n    });\n    return;\n  }\n\n  if (actualTokens > 0 || actualCostUsd > 0) {\n    const sessionState = await addSessionCost(actualTokens, actualCostUsd);\n    await updateSessionCostState({\n      lastActual: {\n        taskId,\n        provider,\n        model,\n        tokensUsed: actualTokens,\n        costUsd: actualCostUsd,\n        createdAt: Date.now(),\n      },\n    });\n\n    sendComplete(tabId, {\n      taskId,\n      success: false,\n      error: result.error || 'Translation failed',\n      provider,\n      model,\n      tokensUsed: actualTokens,\n      estimatedCost: actualCostUsd,\n      sessionTotalTokens: sessionState.totals.totalTokens,\n      sessionTotalCostUsd: sessionState.totals.totalCostUsd,\n    });\n    return;\n  }\n\n  sendComplete(tabId, {\n    taskId,\n    success: false,\n    error: result.error || 'Translation failed',\n    tokensUsed: 0,\n    estimatedCost: 0,\n  });\n}\n\nfunction handleCancel(taskId: string | undefined): void {\n  if (!taskId) return;\n  const controller = activeControllers.get(taskId);\n  if (!controller) return;\n  controller.abort();\n  activeControllers.delete(taskId);\n}\n\n/** VTT fetch timeout (ms) */\nconst VTT_FETCH_TIMEOUT = 10000;\n\n/**\n * Handle FETCH_VTT message from content script\n * Background script can bypass CORS restrictions with proper host_permissions\n * Note: Uses Promise chains instead of async/await to ensure sendResponse works correctly\n */\nfunction handleFetchVTT(\n  payload: { url: string },\n  sendResponse: (response: { ok: boolean; content?: string; error?: string }) => void\n): void {\n  const url = payload?.url;\n\n  if (!url) {\n    sendResponse({ ok: false, error: 'No URL provided' });\n    return;\n  }\n\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), VTT_FETCH_TIMEOUT);\n\n  fetch(url, {\n    method: 'GET',\n    credentials: 'include',\n    signal: controller.signal,\n  })\n    .then((response) => {\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      return response.text();\n    })\n    .then((content) => {\n      sendResponse({ ok: true, content });\n    })\n    .catch((e) => {\n      clearTimeout(timeoutId);\n      const error = e instanceof Error ? e.message : 'Unknown error';\n      if (error.includes('aborted')) {\n        sendResponse({ ok: false, error: 'Request timeout' });\n        return;\n      }\n      sendResponse({ ok: false, error });\n    });\n}\n\nasync function handlePreloadNext(sender: chrome.runtime.MessageSender, payload: any): Promise<void> {\n  const tabId = sender.tab?.id;\n  if (!tabId) return;\n\n  const courseId: string | undefined = payload?.courseId;\n  const nextLectureId: string | undefined = payload?.nextLectureId;\n  if (!courseId || !nextLectureId) return;\n\n  const settings = await loadSettings();\n  if (!isEnabled(settings) || !settings.preloadEnabled) return;\n\n  const existing = activePreloadByTab.get(tabId);\n  if (existing && existing.courseId === courseId && existing.lectureId === nextLectureId) {\n    return;\n  }\n  if (existing) {\n    existing.controller.abort();\n    activePreloadByTab.delete(tabId);\n  }\n\n  const controller = new AbortController();\n  activePreloadByTab.set(tabId, { controller, courseId, lectureId: nextLectureId });\n\n  try {\n    await preloadLecture({\n      courseId,\n      lectureId: nextLectureId,\n      courseName: payload?.courseName,\n      sectionName: payload?.sectionName,\n      lectureName: payload?.nextLectureTitle,\n      signal: controller.signal,\n    });\n  } finally {\n    const current = activePreloadByTab.get(tabId);\n    if (current?.controller === controller) {\n      activePreloadByTab.delete(tabId);\n    }\n  }\n}\n\nfunction initMessageHandler(): void {\n  if (typeof chrome === 'undefined' || !chrome.runtime?.onMessage) return;\n\n  chrome.runtime.onMessage.addListener((message: AnyMessage, sender, sendResponse): void | boolean => {\n    if (!message || typeof message !== 'object' || typeof message.type !== 'string') return;\n\n    // Ignore popup-targeted broadcasts\n    if (message.meta?.target === 'popup') return;\n\n    if (message.type === 'TRANSLATE_SUBTITLE') {\n      handleTranslateSubtitle(sender, message.payload)\n        .then(() => sendResponse?.({ ok: true }))\n        .catch((error) => sendResponse?.({ ok: false, error: String(error) }));\n      return true;\n    }\n\n    if (message.type === 'GET_SETTINGS') {\n      loadSettings()\n        .then((settings) => sendResponse?.({ ok: true, settings }))\n        .catch((error) => sendResponse?.({ ok: false, error: String(error) }));\n      return true;\n    }\n\n    if (message.type === 'PRELOAD_NEXT') {\n      handlePreloadNext(sender, message.payload)\n        .then(() => sendResponse?.({ ok: true }))\n        .catch((error) => sendResponse?.({ ok: false, error: String(error) }));\n      return true;\n    }\n\n    if (message.type === 'CANCEL_TRANSLATION') {\n      handleCancel(message.payload?.taskId);\n      sendResponse?.({ ok: true });\n      return;\n    }\n\n    if (message.type === 'FETCH_VTT') {\n      handleFetchVTT(message.payload, sendResponse);\n      return true;\n    }\n\n    return;\n  });\n}\n\ninitMessageHandler();\n"],
  "mappings": "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",
  "names": ["STORAGE_KEY", "LOG_PREFIX", "WEBVTT_SIGNATURE", "LOG_LEVELS", "currentLogLevel", "log", "WEBVTT_SIGNATURE", "log", "LOG_PREFIX", "LOG_LEVELS", "currentLogLevel", "log", "log", "LOG_PREFIX", "DEFAULT_TIMEOUT", "KEEPALIVE_INTERVAL", "LOG_LEVELS", "currentLogLevel", "log", "keepaliveTimer", "startKeepalive", "log", "KEEPALIVE_INTERVAL", "stopKeepalive", "DEFAULT_TIMEOUT", "handleStreamingResponse", "estimateTokens", "LOG_PREFIX", "DEFAULT_TIMEOUT", "LOG_LEVELS", "currentLogLevel", "log", "DEFAULT_TIMEOUT", "log", "estimateTokens", "LOG_PREFIX", "log"]
}
